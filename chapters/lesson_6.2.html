<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Lesson №6.2 | Функции - часть 1</title>
    <link rel="shortcut icon" href="../images/logo.ico">
    <link rel="stylesheet" href="../css/main.css">
    <!--Fonts-->
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,500,500i,700,700i" rel="stylesheet">

    <link rel="stylesheet" href="../css/atom-one-dark.css">
</head>
<body>
<div class="wrapper">
    <header>
        <a href="/" class="logo">
         <img src="../images/logo.svg" alt="logotype">
        </a>
    </header>
    <main>
        <h1 class="title">Функции - часть 1</h1>
        <h3 class="content-list">Содержание</h3>
        <ul class="plan">
            <li><a href="#s1">Вступление</a></li>
            <li><a href="#s2"></a>**</li>
            <li><a href="#s3"></a>**</li>
            <li><a href="#s4"></a>**</li>
            <li><a href="#s5"></a>**</li>
            <li><a href="#s6"></a>**</li>
            <li><a href="#s7"></a>**</li>
            <li><a href="#s8"></a>**</li>
        </ul>
<!---   SECTION1      -->
        <section class="clearfix" id="s1">
            <article class="main-article fl">
                <h3>1. Вступление</h3>
                <p>
                    <em>
                        Люди считают, что компьютерные науки – это искусство для гениев. В реальности всё наоборот – просто множество людей делают вещи, которые стоят друг на друге, будто составляя стену из маленьких камушков.
                        <br>
                        Дональд Кнут
                    </em>
                </p>
                <p>
                    Количество выполнений цикла, а также выполнение или невыполнение определенной части программы зависит от истинности или ложности вычисляемого выражения. Как правило, такие выражения содержат особый тип операций, называемых операциями отношения, сравнивающими два значения. Поскольку и циклы, и ветвления тесно связаны с операциями отношения, то в первую очередь мы займемся рассмотрением последних.
                </p>
            </article>
        </section>
<!---   SECTION2      -->
        <section class="clearfix" id="s2">
            <article class="main-article fl">
                <h3>2. Операции отношения</h3>
                <p>
                    Операция отношения сравнивает между собой два значения. Сравнение устанавливает одно из четырех возможных отношений между переменными:<br>
                    - больше;<br>
                    - меньше;<br>
                    - равенство(эквивалентность);<br>
                    - строгое равенство(идентичность).<br>
                </p>
                <p>
                    Результатом сравнения является значение истина или ложь. Например, две величины могут быть равны (истина) или не равны (ложь).
                    <br><br>
                    <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var a = prompt('Введите значение a: ', '');
<!-- example -->console.log('a &lt; 10 -', a &lt; 10);
<!-- example -->console.log('a > 10 -', a > 10);
<!-- example -->console.log('a = 10 -', a == 10);
<!-- example -->console.log('a ≠ 10 -', a != 10);
<!-- example --></code></pre>
                <p>
                    Первое выражение истинно в том случае, если значение a меньше, чем 10;
                    второе — тогда, когда a больше, чем 10; третье — когда a равно 10. и наконец a не равно 10. Как можно видеть из результата работы программы, интерпретатор JavaScript возвращает на место операции отношения значение true или false.
                </p>
                <h4>2.1 Сравнение разных типов</h4>
                <p>
                    При сравнении значений разных типов, используется <strong>числовое преобразование</strong> за правилами преобразование типов. Оно применяется к обоим значениям.<br><br>
                    <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->alert( '2' > 1 ); // true, сравнивается как 2 > 1
<!-- example -->alert( '01' == 1 ); // true, сравнивается как 1 == 1
<!-- example -->alert( false == 0 ); // true, false становится числом 0
<!-- example -->alert( true == 1 ); // true, так как true становится числом 1.
<!-- example --></code></pre>
                <h4>2.2 Строгое равенство</h4>
                <p>
                    В обычном операторе == есть «проблема» – он не может отличить 0 от false:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->alert( 0 == false );  // true
<!-- example --></code></pre>
                <p>
                    Та же ситуация с пустой строкой:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->alert( ''  == false ); // true
<!-- example --></code></pre>
                <p>
                    Это естественное следствие того, что операнды разных типов преобразовались к числу. Пустая строка, как и false, при преобразовании к числу дают 0.
                </p>
                <p>
                    Что же делать, если всё же нужно отличить 0 от false?
                </p>
                <p>
                    <strong>Для проверки равенства без преобразования типов используются операторы строгого равенства === (тройное равно) и !==.</strong>
                </p>
                <p>
                   Если тип разный, то они всегда возвращают false:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->alert( 0 === false ); // false, т.к. типы различны
<!-- example --></code></pre>
                <p>
                    Строгое сравнение предпочтительно, если мы хотим быть уверены, что «сюрпризов» не будет.
                </p>
            </article>
            <article class="side-article fr">
                <h3>2.3* Сравнение с null и undefined</h3>
                <p>
                    Проблемы со специальными значениями возможны, когда к переменной применяется операция сравнения > &lt; &lt;= >=, а у неё может быть как численное значение, так и null/undefined.
                </p>
                <p>
                    <strong>Интуитивно кажется, что null/undefined эквивалентны нулю, но это не так.</strong>
                </p>
                <p>
                    Они ведут себя по-другому.<br>
                    1. Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка.<br>
                    2. При преобразовании в число null становится 0, а undefined становится NaN.
                </p>
                <p>
                    Посмотрим забавные следствия.
                </p>
                <h4>2.3.1 Некорректный результат сравнения null с 0</h4>
                <p>
                    Сравним null с нулём:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->alert( null > 0 ); // false
<!-- example -->alert( null == 0 ); // false
<!-- example --></code></pre>
                <p>
                    И так, мы получили, что null не больше и не равен нулю. А теперь…
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->alert( null >= 0 ); // true
<!-- example --></code></pre>
                <p>
                    Как такое возможно? Если нечто «больше или равно нулю», то резонно полагать, что оно либо больше, либо равно. Но здесь это не так.
                </p>
                <p>
                    Дело в том, что алгоритмы проверки равенства == и сравнения >= > &lt; &lt;= работают по-разному.
                </p>
                <p>
                    Сравнение честно приводит к числу, получается ноль. А при проверке равенства значения null и undefined обрабатываются особым образом: они равны друг другу, но не равны чему-то ещё.
                </p>
                <p>
                    В результате получается странная с точки зрения здравого смысла ситуация, которую мы видели в примере выше.
                </p>
                <h4>2.3.2 Несравнимый undefined</h4>
                <p>
                    Значение undefined вообще нельзя сравнивать:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->alert( undefined > 0 ); // false (1)
<!-- example -->alert( undefined &lt; 0 ); // false (2)
<!-- example -->alert( undefined == 0 ); // false (3)
<!-- example --></code></pre>
                <p>
                    - Сравнения (1) и (2) дают false потому, что undefined при преобразовании к числу даёт NaN. А значение NaN по стандарту устроено так, что сравнения ==, &lt;, >, &lt;=, >= и даже === с ним возвращают false.<br>
                    - Проверка равенства (3) даёт false, потому что в стандарте явно прописано, что undefined равно лишь null и ничему другому.
                </p>
                <p>
                    <strong>Вывод: любые сравнения с undefined/null, кроме точного ===, следует делать с осторожностью.</strong>
                </p>
                <p>
                    Желательно не использовать сравнения >= > &lt; &lt;= с ними, во избежание ошибок в коде.
                </p>
            </article>
        </section>
<!---   SECTION3      -->
        <section class="clearfix" id="s3">
            <article class="main-article fl">
                <h3>3. Ветвления</h3>
                <p>
                    В программе решение, или ветвление, сводится к переходу в другую часть программы в зависимости от значения соответствующего выражения.
                </p>
                <p>
                    В JavaScript существует несколько типов ветвлений, наиболее важным из которых является if...else, осуществляющее выбор между двумя альтернативами. В инструкции ветвления if...else использование else не является обязательным. Для выбора одной из множества альтернатив используется инструкция ветвления switch(switch Statement), действие которого определяется набором значений соответствующей переменной. Кроме того, существует так называемая условная операция, используемая в некоторых особых ситуациях. Мы рассмотрим каждую из этих конструкций.
                </p>
                <h4>3.1 The if Statement/Инструкция if</h4>
                <h4>3.3.1 Оператор if</h4>
                <p>
                    Оператор <strong>if</strong> является наиболее простым из операторов ветвлений. Следующие примеры иллюстрируют применение оператора if.<br><br>
                    <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var a = prompt('Введите значение a: ', '');
<!-- example -->if ( a > 100 )
<!-- example -->    alert('Это число больше, чем 100');
<!-- example --></code></pre>
                <p>
                    За ключевым словом if следует условие ветвления, заключенное в круглые скобки. Оператор <strong>if (...) вычисляет и преобразует выражение в скобках к логическому типу.</strong>
                    <br><br>
                <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var year = prompt('В каком году появилась спецификация ECMA-262 5.1?', '');
<!-- example -->if (year != 2011)
<!-- example -->    alert( 'А вот и неправильно!' );
<!-- example --></code></pre>
                <p>
                    Оператор if («если») получает условие, в примере выше это year != 2011. Он вычисляет его, и если результат – true, то выполняет команду.
                </p>
                <h4>3.3.2 Несколько операторов в теле if</h4>
                <p>
                    Если нужно выполнить более одной команды – они оформляются блоком кода в фигурных скобках:
                    <br><br>
                    <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->if (year != 2011) {
<!-- example -->    alert( 'А вот..' );
<!-- example -->    alert( '..и неправильно!' );
<!-- example -->}
<!-- example --></code></pre>
                <p>
                    <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var x = prompt('Введите число: ', '');
<!-- example -->if (x > 100) {
<!-- example -->    alert('Число ', x);
<!-- example -->    alert('больше, чем 100');
<!-- example -->}
<!-- example --></code></pre>
                <p>
                    <strong>Рекомендуется использовать фигурные скобки всегда, даже когда команда одна.</strong>
                </p>
                <p>
                    Это улучшает читаемость кода.
                </p>
                <p>
                    Синтаксис оператора if показан на рисунке:
                </p>
                <div class="article-images small-img">
                    <img src="images/if syntax images.jpg" alt="example img">
                </div>
                <h4>3.3.3 Оператор if...else</h4>
                <p>
                    Оператор if позволяет совершать действие в том случае, если выполняется некоторое условие. Если же условие не выполняется, никакого действия не выполняется. Однако, можно представить такую ситуацию, когда нам необходимо совершить одно действие в случае выполнения условия и другое действие в случае невыполнения этого условия. Здесь оказывается полезным ветвление <strong>if...else</strong>. Оно состоит из оператора if, за которым следует блок операторов, и ключевого слова else, за которым следует еще  один блок операторов. Синтаксис ветвления показан на рисунке:
                </p>
                <div class="article-images small-img">
                    <img src="images/if else syntax images.jpg" alt="">
                </div>
                <p>
                    <br>
                    <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var a = prompt('Введите число: ', '');
<!-- example -->if (a > 100)
<!-- example -->    alert('Это число больше, чем 100');
<!-- example -->else
<!-- example -->    alert('Это число не больше, чем 100');
<!-- example --></code></pre>
                <p>
                    <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var year = prompt('Введите год появления стандарта ECMA-262 5.1', '');
<!-- example -->if (year == 2011) {
<!-- example -->    alert( 'Да вы знаток!' );
<!-- example -->} else {
<!-- example -->    alert( 'А вот и неправильно!' ); // любое значение, кроме 2011
<!-- example -->}
<!-- example --></code></pre>
                <p>
                    В зависимости от истинности или ложности условия ветвления, программа выводит соответствующее сообщение.
                </p>
                <h4>3.3.4 Вложенные ветвления if...else</h4>
                <p>
                    Возможно, вам приходилось видеть приключенческие игры, предназначенные для ранних версий MS DOS. Их суть заключалась в следующем: играющий двигал своего «героя» по воображаемому ландшафту и замкам среди волшебников, сокровищ и т. д.,  с помощью текстовых символов. Следующии пример, напоминает небольшую часть такой приключенческой игры. <br><br>
                    <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var x = 10, y = 10, position = '';
<!-- example -->alert('Введите \'end\' для выхода...');
<!-- example -->if (position != 'end') {
<!-- example -->    alert('Ваши координаты: ' + x + ',' + y);
<!-- example -->    position = prompt('Выберите направление (n, s, e, w): ', '');
<!-- example -->    if (position == 'n') // движение на север
<!-- example -->        y--;
<!-- example -->    else
<!-- example -->        if (position == 's') // движение на юг
<!-- example -->            y++;
<!-- example -->        else
<!-- example -->            if (position == 'e') // движение на восток
<!-- example -->                x++;
<!-- example -->            else
<!-- example -->                if (position == 'w') // движение на запад
<!-- example -->            		x--;
<!-- example -->alert('Ваши координаты: ' + x + ',' + y);
<!-- example -->}
<!-- example --></code></pre>
                <p>
                    Когда игра начинается, вы оказываетесь на бесплодном участке земли. Вы можете передвигаться на север, юг, запад и восток, а программа будет следить за вашими передвижениями и сообщать ваши текущие координаты. Начало дви­жения находится в точке с координатами (10, 10). С вашим героем не будет происходить ничего интересного, куда бы он ни пошел; пустая земля простира­ется во всех направлениях, как видно на рисунке:
                </p>
                <div class="article-images small-img-7">
                    <img src="images/if else example images.jpg" alt="">
                </div>
                <p>
                    Для выхода из программы нужно ввести слово ‘end’.
                </p>
                <p>
                    Данная програма не являеться шедевром среди видеоигр, однако в ней демонстрируется применение вложенных ветвлений. Так, оператор if находится внутри оператора if...else, который, в свою очередь, также является частью ветвления if...else. Если первое условие не выполняется, то проверяется второе условие и т. д. до тех пор, пока не будут проверены все условия. Если какое-либо из условий выполняется, то изменяется соответствующая координата x или у, после чего программа выходит из всех вложенных ветвлений. Подобные вложенные группы ветвлений называются <strong>деревом ветвлений</strong>.
                </p>
                <h4>3.3.5 Конструкция else...if</h4>
                <p>
                    Вложенные ветвления if...else выглядят несколько неуклюже и могут представлять трудность для восприятия, особенно если глубина вложенности больше или тело оператора if...else является блоком кода. <br><br>
                    <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var x = 10, y = 10, position = '';
<!-- example -->alert('Введите \'end\' для выхода...');
<!-- example -->if (position != 'end') {
<!-- example -->    alert('Ваши координаты: ' + x + ',' + y);
<!-- example -->    position = prompt('Выберите направление (n, s, e, w): ', '');
<!-- example -->    if (position == 'n') { // движение на север
<!-- example -->        y--;
<!-- example -->        console.log('go north');
<!-- example -->    } else {
<!-- example -->        if (position == 's') { // движение на юг
<!-- example -->            y++;
<!-- example -->            console.log('go south');
<!-- example -->        } else {
<!-- example -->            if (position == 'e') { // движение на восток
<!-- example -->         		x++;
<!-- example -->                console.log('go east');
<!-- example -->            } else {
<!-- example -->                if (position == 'w') {  // движение на запад
<!-- example -->                    x--;
<!-- example -->                    console.log('go west');
<!-- example -->                }
<!-- example -->            }
<!-- example -->        }
<!-- example -->    }
<!-- example -->alert('Ваши координаты: ' + x + ',' + y);
<!-- example -->}   
<!-- example --></code></pre>
                <p>
                    Существует еще один вариант записи этих же действий. Необходимо только немного изменить последовательность записи кода программы. В результате получим следующий пример:
                    <br><br>
                    <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var x = 10, y = 10, position = '';
<!-- example -->alert('Введите \'end\' для выхода...');
<!-- example -->if (position != 'end') {
<!-- example -->    alert('Ваши координаты: ' + x + ',' + y);
<!-- example -->    position = prompt('Выберите направление (n, s, e, w): ', '');
<!-- example -->    if (position == 'n') { // движение на север
<!-- example -->        y--;
<!-- example -->        console.log('go north');
<!-- example -->    } else if (position == 's') { // движение на юг
<!-- example -->            y++;
<!-- example -->            console.log('go south');
<!-- example -->        } else if (position == 'e') { // движение на восток
<!-- example -->         		x++;
<!-- example -->                console.log('go east');
<!-- example -->            } else if (position == 'w') {  // движение на запад
<!-- example -->                    x--;
<!-- example -->                    console.log('go west');
<!-- example -->                }           		   
<!-- example -->}
<!-- example -->alert('Ваши координаты: ' + x + ',' + y);
<!-- example --></code></pre>
                <p>
                    У вас может создаться впечатление, что мы использовали новый вид ветвления else...if. Программа последовательно исполняет блоки else...if до тех пор, пока не выполнится хотя бы одно из проверяемых условий. Затем исполняется соответствующий оператор и производится выход из ветвлений. Такой способ представления вложенных ветвлений гораздо проще и удобнее для понимания, чем обычная последовательность конструкций if...else.
                </p>
                <h4>3.3.6 Условная операция, тернарный оператор(Conditional Operator)</h4>
                <p>
                    В этом разделе пойдет разговор об операции, выполняющей несколько нетипичные действия. Существует распространенная в программировании ситуация: переменной необходимо присвоить одно значение в случае выполнения некоторого условия и другое значение в случае невыполнения этого условия. В следующем примере переменной min присваивается наименьшее из значений alpha и beta с помощью конструкции if...else:
                    <br><br>
                    <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var alpha = 1, beta = 2;
<!-- example -->if (alpha &lt; beta) {
<!-- example -->    min = alpha;
<!-- example -->} else {
<!-- example -->    min = beta;
<!-- example -->}
<!-- example --></code></pre>
                <p>
                    Подобные действия на практике оказались настолько распространенными, что была специально разработана условная операция, выполняющая эти действия. Эта операция записывается с помощью двух знаков и использует три операнда. Она является единственной операцией в JavaScript, использующей более двух операндов. С помощью условной операции можно записать предыдущий фрагмент следующим образом:
                    <br><br>
                    <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var alpha = 1, beta = 2;
<!-- example -->min = (alpha &lt; beta) ? alpha : beta;
<!-- example --></code></pre>
                <p>
                    Правая часть оператора представляет собой условное выражение:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->(alpha &lt; beta) ? alpha : beta; // условное выражение
<!-- example --></code></pre>
                <p>
                    Если значение проверяемого условия истинно, то условное выражение становится равным значению alpha; в противном случае оно становится равным beta. Скобки вокруг проверяемого условия не обязательны, но их довольно часто употребляют для того, чтобы упростить визуальное восприятие этого оператора. 
                </p>
<pre><code class="javascript"><!--
-->условие ? значение1 : значение2;
</code></pre>
                <p>
                    На рисунке показан синтаксис оператора условия:
                </p>
                <div class="article-images small-img-7">
                    <img src="images/conditional Operator syntax images.jpg" alt="">
                </div>
                <h4>3.3.7 Несколько условных операторов</h4>
                <p>
                    Последовательность операторов '?' позволяет вернуть значение в зависимости не от одного условия, а от нескольких.
                    <br><br>
                    <u>Пример</u>
                </p>
<pre><code class="javascript"><!--
-->'use strict';
var age = prompt('Ваш возраст?', 18);
var message = (age &lt; 3) ? 'Здравствуй, малыш!' :
    (age &lt; 18) ? 'Привет!' :
        (age &lt; 100) ? 'Здравствуйте!' :
            'Какой необычный возраст!';
alert( message );
</code></pre>
                <p>
                    Поначалу может быть сложно понять, что происходит. Однако, внимательно приглядевшись, мы замечаем, что это обычная последовательная проверка.
                </p>
                <p>
                    Вопросительный знак проверяет сначала age &lt; 3, если верно – возвращает 'Здравствуй, малыш!', если нет – идет за двоеточие и проверяет age &lt; 18. Если это верно – возвращает 'Привет!', иначе проверка age &lt; 100 и 'Здравствуйте! И наконец, если ничего из этого не верно, то 'Какой необычный              возраст!'.
                </p>
                <p>
                    То же самое через if..else:
                    <br><br>
                    <u>Пример</u>
                </p>
<pre><code class="javascript"><!--
-->'use strict';
var age = prompt('Ваш возраст?', 18);
if (age &lt; 3) {
    message = 'Здравствуй, малыш!';
} else if (age &lt; 18) {
    message = 'Привет!';
} else if (age &lt; 100) {
    message = 'Здравствуйте!';
} else {
    message = 'Какой необычный возраст!';
}
alert( message );
</code></pre>
                <h4>3.2 The switch Statement/Инструкция switch</h4>
                <h4>3.2.1 Оператор switch..case..default</h4>
                <p>
                    Если в вашей программе присутствует большое дерево ветвлений и все ветвления зависят от значения какой-либо одной переменной, то можно вместо ступенчатой последовательности конструкций if...else или else...if воспользоваться инструкцией <strong>switch</strong>. Рассмотрим простой пример:
                    <br><br>
                    <u>Пример</u>
                </p>
<pre><code class="javascript"><!--
-->'use strict';
var month = +prompt('Введите месяц в формате 1, 2...12', '1');
switch (month) { 
    case 1:
        alert('Январь');
        break;
    case 2:
        alert('Февраль ');
        break;
    case 3:
        alert('Март');
        break;
    case 4:
        alert('Апрель');
        break;
    case 5:
        alert('Май');
        break;
    case 6:
        alert('Июнь');
        break;
    case 7:
        alert('Июль');
        break;
    case 8:
        alert('Август');
        break;
    case 9:
        alert('Сентябрь');
        break;
    case 10:
        alert('Октябрь');
        break;
    case 11:
        alert('Ноябрь');
        break;
    case 12:
        alert('Декабрь');
        break;
}
</code></pre>
                <p>
                    Различные места в блоке помечены ключевым словом <strong>case</strong>, за которым следует выражение и символ двоеточия. Ключевое слово case напоминает инструкцию с меткой за исключением того, что оно связывает инструкцию с выражением, а не с именем. Когда выполняется инструкция switch, она вычисляет значение вы­ра­же­ния, а затем ищет метку case, соответствующую этому значению (соответствие определяется с помощью <strong>оператора идентичности ===</strong>). Если метка найдена, выполняется блок кода следующей за меткой case. Если метка case с соответствующим значением не найдена, выполнение начинается с первой инструкции, следующей за специальной меткой <strong>default:</strong>. Если метка default: отсутствует, блок инструкции switch пропускается целиком.
                </p>
                <p>
                    Обратите внимание на ключевое слово <strong>break</strong> в конце каждого блока case. Инструкция break, описываемая далее в следующий главе, приводит к передаче управления в конец инструкции switch и продолжению выполнения инструкций, следующих далее. Конструкции case в инструкции switch задают только начальную точку выполняемого программного кода, но не задают никаких конечных точек. В случае отсутствия инструкций break инструкция switch начнет выполнение блока кода с меткой case, соответствующей значению вы­ра­же­ния, и продолжит выполнение инструкций до тех пор, пока не дойдет до конца блока. В редких случаях это полезно.
                    <br><br>
                    <u>Пример</u>
                </p>
<pre><code class="javascript"><!--
-->'use strict';
var month = +prompt('Введите месяц в формате 1, 2...12', '1');
switch (month) { 
    case 1:
        alert('Январь');
        break;
    case 2:
        alert('Февраль ');
        break;
    case 12:
        alert('Декабрь');
        break;
    default:
        alert(month + ' - это не зимний месяц');
}
</code></pre>
                <h4>3.2.2 Группировка case</h4>
                <p>
                    Несколько значений case можно группировать:
                    <br><br>
                    <u>Пример</u>
                </p>
<pre><code class="javascript"><!--
-->'use strict';
var month = +prompt('Введите месяц в формате 1, 2...12', '1');
switch (month) {
    case 12: 
    case 1:
    case 2:
        alert('Зимний месяц');
        break;
    case 3:
    case 4:
    case 5:
        alert('Весенний месяц');
        break;
    case 6:
    case 7:
    case 8:
        alert('Летний месяц');
        break;
    case 9:
    case 10:
    case 11:
        alert('Осенний месяц');
        break;
}
</code></pre>
                <h4>3.3 Сравнение switch и if ... else</h4>
                <p>
                    Когда лучше использовать последовательность if...else (или else...if), а когда — switch? При использовании else...if можно проверять значения разных не связанных друг с другом переменных, причем сравнения могут быть любой степени сложности:
                    <br><br>
                    <u>Пример</u>
                </p>
<pre><code class="javascript"><!--
-->'use strict';
if (SteamPressure * Factor > 56)
   // statement
else if (Voltageln + VoltageOut &lt; 23000)
   // statement
else if (day == Thursday)
   // statement
else
   // statement
</code></pre>
                <p>
                    В операторе switch все ветвления используют одну и ту же переменную(выражение) единственная возможность проверки в таком ветвлении — сравнение значения переменной с заданной константой. Если хорошо усвоить эти условия, написание конструкций switch становится простым и доступным для понимания, switch рекомендуется использовать там, где это возможно, особенно в случаях, когда дерево ветвлений содержит много ветвей.
                </p>
            </article>
            <article class="side-article fr">
                <h3>3.1.8* Нетрадиционное использование условных операторов</h3>
                <p>
                    Иногда оператор вопросительный знак '?' используют как замену if:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var company = prompt('Какая компания создала JavaScript?', '');
<!-- example -->
<!-- example -->(company == 'Netscape') ?
<!-- example -->   alert('Да, верно') : alert('Неправильно');
<!-- example --></code></pre>
                <p>
                    Работает это так: в зависимости от условия, будет выполнена либо первая, либо вторая часть после '?'. Результат выполнения не присваивается в переменную, так что пропадёт (впрочем, alert ничего не возвращает).
                </p>
                <p>
                    <strong>Рекомендуется не использовать вопросительный знак таким образом.</strong>
                </p>
                <p>
                    Несмотря на то, что с виду такая запись короче if, она является существенно менее читаемой. При чтении кода глаз идёт вертикально и конструкции, занимающие несколько строк, с понятной вложенностью, воспринимаются гораздо легче. Возможно, вы и сами почувствуете, пробежавшись глазами, что синтаксис с if более прост и очевиден чем с оператором '?'.
                </p>
                <p>
                    Смысл условного оператора – вернуть то или иное значение, в зависимости от условия. Пожалуйста, используйте его по назначению, а для выполнения разных веток кода есть if.
                </p>
            </article>
        </section>
        <!---   SECTION4      -->
        <section class="clearfix" id="s4">
            <article class="main-article fl">
                <h3>4. Объект Math</h3>
                <p>
                    Объект Math является встроенным объектом, хранящим в своих свойствах и методах различные математические константы и функции.
                </p>
                <h4>4.1 Свойства объекта Math</h4>
                <div class="object-property">
                    <h5>Math.E</h5>
                    <p>Константа e, основание натуральных логарифмов.</p>
                    <pre><code class="javascript">Math.E; // 2.718281828459045</code></pre>
                </div>
                <div class="object-property">
                    <h5>Math.LN10</h5>
                    <p>Натуральный логарифм числа 10.</p>
                    <pre><code class="javascript">Math.LN10; // 2.302585092994046</code></pre>
                </div>
                <div class="object-property">
                    <h5>Math.LN2</h5>
                    <p>Натуральный логарифм числа 2.</p>
                    <pre><code class="javascript">Math.LN2; // 0.6931471805599453</code></pre>
                </div>
                <div class="object-property">
                    <h5>Math.LOG10E</h5>
                    <p>Десятичный логарифм числа e.</p>
                    <pre><code class="javascript">Math.LOG10E; // 0.4342944819032518</code></pre>
                </div>
                <div class="object-property">
                    <h5>Math.LOG2E</h5>
                    <p>Логарифм числа e по основанию 2.</p>
                    <pre><code class="javascript">Math.LOG2E; // 1.4426950408889634</code></pre>
                </div>
                <div class="object-property">
                    <h5>Math.PI</h5>
                    <p>Константа числа π.</p>
                    <pre><code class="javascript">Math.PI; //  3.141592653589793</code></pre>
                </div>
                <div class="object-property">
                    <h5>Math.SQRT1_2</h5>
                    <p>Единица, деленная на корень квадратный из 2.</p>
                    <pre><code class="javascript">Math.SQRT1_2; // 0.7071067811865476</code></pre>
                </div>
                <div class="object-property">
                    <h5>Math.SQRT2</h5>
                    <p>Квадратный корень из 2.</p>
                    <pre><code class="javascript">Math.SQRT2; // 1.4142135623730951</code></pre>
                </div>  
                <h4>4.2 Методы объекта Math</h4>
                <p class="warning">
                    Обратите внимание, что тригонометрические функции (sin(), cos(), tan(), asin(), acos(), atan() и atan2()) принимают в параметрах или возвращают углы в радианах. Для преобразования радианов в градусы, умножьте их на величину на (180 / Math.PI);
                </p>
                <p class="warning">
                    Обратите внимание, что точность большинства математических функций зависит от реализации. Это означает, что различные браузеры могут дать разные результаты, более того, даже один и тот же движок JavaScript на различных операционных системах или архитектурах может выдать разные результаты.
                </p>
                <div class="object-method-wrapper">
                    <div class="object-method">
                        <h5>Math.abs( x )</h5>
                        <p>Возвращает абсолютное значение числа.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.acos( x )</h5>
                        <p>Возвращает арккосинус числа.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.acosh( x )</h5>
                        <p>Возвращает гиперболический арккосинус числа.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.asin( x )</h5>
                        <p>Возвращает арксинус числа.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.asinh( x )</h5>
                        <p>Возвращает гиперболический арксинус числа.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.atan( x )</h5>
                        <p>Возвращает арктангенс числа.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.atanh( x )</h5>
                        <p>Возвращает гиперболический арктангенс числа.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.atan2( y, x )</h5>
                        <p>Возвращает арктангенс от частного своих аргументов.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.cbrt( x )</h5>
                        <p>Возвращает кубический корень числа.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.ceil( x )</h5>
                        <p>Возвращает наименьшее целое число, большее, либо равное указанному числу.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.clz32( x )</h5>
                        <p>Возвращает количество ведущих нулей 32-битного целого числа.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.cos( x )</h5>
                        <p>Возвращает косинус числа.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.cosh( x )</h5>
                        <p>Возвращает гиперболический косинус числа.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.exp( x )</h5>
                        <p>Вычисляет степень числа e.</p> 
                    </div> 
                    <div class="object-method">
                        <h5>Math.expm1( x )</h5>
                        <p>Возвращает exp(x), из которого вычли единицу.</p>
                    </div> 
                    <div class="object-method"> 
                        <h5>Math.floor( x )</h5>
                        <p>Возвращает наибольшее целое число, меньшее, либо равное указанному числу.</p>
                    </div> 
                    <div class="object-method"> 
                        <h5>Math.fround( x )</h5>
                        <p>Округляет до ближайшего целого.</p>
                    </div> 
                    <div class="object-method"> 
                        <h5>Math.hypot( value1, value2, ...values )</h5>
                        <p>Возвращает квадратный корень из суммы квадратов своих аргументов.</p>
                    </div> 
                    <div class="object-method"> 
                        <h5>Math.imul( x, y )</h5>
                        <p>Возвращает результат умножения 32-битных целых чисел.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.log( x )</h5>
                        <p>Возвращает натуральный логарифм числа.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.log1p( x )</h5>
                        <p>Возвращает натуральный логарифм числа 1 + x</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.log10( x )</h5>
                        <p>Возвращает десятичный логарифм числа.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.log2( x )</h5>
                        <p>Возвращает двоичный логарифм числа.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.max( value1, value2, ...values )</h5>
                        <p>Возвращает наибольшее число из своих аргументов.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.min( value1, value2, ...values )</h5>
                        <p>Возвращает наименьшее число из своих аргументов.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.pow( base, exponent )</h5>
                        <p>Вычисляет base в степени exponent.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.random( )</h5>
                        <p>Возвращает псевдослучайное число в диапазоне от 0 до 1.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.round( x )</h5>
                        <p>Возвращает значение числа, округлённое до ближайшего целого.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.sign( x )</h5>
                        <p>Возвращает знак числа, указывающий, является ли число положительным, отрицательным или нулём.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.sin( x )</h5>
                        <p>Возвращает синус числа.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.sinh( x )</h5>
                        <p>Возвращает гиперболический синус числа.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.sqrt( x )</h5>
                        <p>Возвращает положительный квадратный корень числа.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.tan( x )</h5>
                        <p>Возвращает тангенс числа.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.tanh( x )</h5>
                        <p>Возвращает гиперболический тангенс числа.</p>
                    </div> 
                    <div class="object-method">
                        <h5>Math.trunc( x )</h5>
                        <p>Возвращает целую часть числа, убирая дробные цифры.</p>
                    </div> 
                </div> 
            </article>
        </section>
<!---   SECTION5      -->
        <section class="clearfix" id="s5">
            <article class="main-article fl">
                <h3>5. Циклы(Loops)</h3>
                <p>
                    Действие циклов заключается в последовательном повторении определенной части вашей программы некоторое количество раз. Повторение продолжается до тех пор, пока выполняется соответствующее условие. Когда значение выражения, задающего условие, становится ложным, выполнение цикла   прекращается, а управление передается оператору, следующему непосредственно за циклом.
                </p>
                <p>
                    Инструкции циклов можно представить как разворот на дороге, возвращающий обратно, который заставляет интерпретатор многократно проходить через один и тот же участок программного кода.
                </p>
                <p>
                    В JavaScript(стандарт ES6) существует 5 типов циклов:<br>
                    - do...while;<br>
                    - while;<br>
                    - for;<br>
                    - for..in;<br>
                    - for..of;
                </p>
                <p>
                    Повторение цикла называется итерацией, а инструкции циклов в <a href="">спецификации</a> называються итерирующими инструкциям(<em>IterationStatement</em>)
                </p>
                <p>
                    Циклы for...in и for...of мы рассмотрим в последующих главах курса.
                </p>
                <h4>5.1 The for Statement/Цикл for</h4>
                <p>
                    Большинство изучающих язык JavaScript считают цикл <strong>for</strong> самым легким для понимания. Все элементы, контролирующие его выполнение, собраны в одном месте, в то время как в циклах других типов они разбросаны внутри цикла, что зачастую делает логику его работы трудной для понимания.
                </p>
                <p>
                    Цикл for организует выполнение фрагмента программы фиксированное число раз. Как правило (хотя и не всегда), этот тип цикла используется тогда, когда число раз, за которое должно повториться исполнение кода, известно заранее.
                </p>
                <p>
                    В примере ниже, выводятся на экран квадраты целых чисел от 0 до 5:
                    <br><br>
                    <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var i;
<!-- example -->for (i = 0; i &lt;= 5; i++)
<!-- example -->    alert(Math.pow(i, 2));
<!-- example --></code></pre>
                <p>
                    Каким образом работает эта программа? Оператор for управляет циклом. Он состоит из ключевого слова for, за которым следуют круглые скобки, содержащие три выражения, разделенные точками с запятой:
                </p>
<!-- example --><pre><code class="javascript">(i = 0; i &lt;= 5; i++)</code></pre>
                <p>
                    Первое из трех выражений называют инициализирующим, второе — условием проверки, а третье — инкрементирующим, как показано на рисунке ниже:
                </p>
<!-- image  --><div class="article-images small-img-7">
<!-- image  -->    <img src="images/for image.jpg" alt="">
<!-- image  --></div>
                <p>  
                    Эти три выражения, как правило (но не всегда), содержат одну переменную, которую обычно называют счетчиком цикла. В примере выше <strong>счетчиком</strong> цикла является переменная <strong>i</strong>. Она определяется до того, как начнет исполняться тело цикла.
                </p>
                <p>
                    Под телом цикла понимается та часть кода, которая периодически исполняется в цикле. В нашем примере тело цикла состоит из единственной инструкции:
                </p>
<!-- example --><pre><code class="javascript">alert(Math.pow(i, 2));</code></pre>    
                <p>
                    Рассмотрим, каким образом три выражения, стоящие в круглых скобках инсиукции for, влияют на работу цикла.
                </p>  
                <p>
                    - <strong>Инициализирующее выражение</strong> вычисляется только один раз — в начале выполнения цикла. Вычисленное значение инициализирует счетчик цикла. В примере выше переменная i получает значение 0.
                </p>          
                <p>
                    - Как правило, <strong>условие</strong> выполнения цикла содержит в себе операцию отношения. Условие проверяется каждый раз перед исполнением тела цикла и определяет, нужно ли исполнять цикл еще раз или нет. Если условие выполняется, то есть соответствующее выражение истинно, то цикл исполняется еще раз. В противном случае управление передается тому оператору, который следует за циклом.
                </p>          
                <p>
                    - <strong>Инкрементирующее выражение</strong> предназначено для изменения значения счетчика цикла. Часто такое изменение сводится к инкрементированию счетчика. Модификация счетчика происходит после того, как тело цикла полностью выполнилось. В нашем примере увеличение i на единицу происходит каждый раз после завершения тела цикла.
                </p> 
                <h4>5.1.1 Несколько инструкций в теле цикла</h4>
                <p>
                    Разумеется, вам может понадобиться выполнить в теле цикла не одину, а несколько  инструкций. Тогда эти несколько инструкций необходимо заключить в фигурные скобки, как мы поступали с телом инструкции ветвления. Обратите внимание на то, что после закрывающей фигурной скобки не следует ставить точку с запятой подобно тому, как мы делаем в конце операторов, входящих в тело цикла.
                </p>
                <h4>5.1.2 Варианты цикла for</h4>   
                <p>
                    Инкрементирующий оператор не обязательно должен производить операцию инкрементирования счетчика цикла; вместо инкрементирования может использоваться любая другая операция. В следующем примере под названием FACTOR в операторе цикла используется декрементирование счетчика цикла. Программа запрашивает значение у пользователя, а затем подсчитывает факториал этого числа (факториал числа представляет из себя произведение всех целых положительных чисел, не превышающих данное число. Например, факториал числа 5 равен 1*2*3*4*5 = 120).
                    <br><br>
                    <u>Пример FACTOR</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var a = prompt('Введите значение a: ', '');
<!-- example -->for (var i = a, fact = 1; i > 0; i--) {
<!-- example -->    fact *= i;
<!-- example -->}
<!-- example -->alert(fact);
<!-- example --></code></pre>
                <p>
                    В этом примере инициализирующий оператор присваивает переменной <strong>i</strong> значение, вводимое пользователем. Условием продолжения цикла является положительность значения <strong>i</strong>. Инкрементирующее выражение после каждой итерации уменьшает значение <strong>i</strong> на единицу.
                </p>
                <p>
                    <strong>Определение счетчика цикла внутри оператора цикла for: </strong>
                </p>
                <p>
                    В последней программе есть еще одно полезное нововведение: переменная i описана прямо внутри оператора цикла.
                </p>
                <p>
                    Подобная конструкция является типичной для JavaScript, и, как правило, наиболее удобна для работы со счетчиками цикла. Такое определение переменной стоит наиболее близко к месту ее употребления. Переменная, описанная в операторе цикла, видна от точки объявления до конца программы.
                </p>
                <p>
                    <strong>Несколько инициализирующих выражений и условий цикла:</strong>
                </p>
                <p>
                    Вместо одного инициализирующего выражения в операторе цикла for можно использовать несколько выражений, разделяемых запятыми. Подобным же образом можно использовать более одного инкрементирующего выражения. Лишь условие продолжения цикла всегда должно быть одно, как показано в примере FACTOR.
                </p>
                <p>
                    <strong>Любое выражение в for может быть пропущено:</strong>
                    <br><br>
                    <u>Пример FACTOR 2.0</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var a = prompt('Введите значение a: ', '');
<!-- example -->var i = a, fact = 1;
<!-- example -->for (; i > 0; i--) {
<!-- example -->    fact *= i;
<!-- example -->}
<!-- example -->alert(fact);
<!-- example --></code></pre>
                <p>
                    <strong>Инкрементирующее же выражение может быть внесено в тело цикла:</strong>
                    <br><br>
                    <u>Пример FACTOR 3.0</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var a = prompt('Введите значение a: ', '');
<!-- example -->var i = a, fact = 1;
<!-- example -->for (; i > 0;) {
<!-- example -->    fact *= i;
<!-- example -->    i--;
<!-- example -->}
<!-- example -->alert(fact)
<!-- example --></code></pre>
                <p>
                    <strong>А можно и вообще убрать всё, получив бесконечный цикл.</strong>
                    <br><br>
                    <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->for (;;) {
<!-- example -->    //statement
<!-- example -->}
<!-- example --></code></pre>
                <p>
                    <strong>При этом сами точки с запятой ; обязательно должны присутствовать, иначе будет ошибка синтаксиса.</strong>
                </p>
                <h4>5.2 The while Statement/Цикл while</h4>
                <p>
                    Цикл for выполняет последовательность действий определенное количество раз. А как поступить в том случае, если заранее не известно, сколько раз понадобится выполнить цикл? Для этого разработан другой вид цикла — <strong>while</strong>.
                </p>
                <p>
                    В следующем примере пользователю предлагают ввести серию значений. В том случае, когда вводимое значение оказывается равным нулю, происходит выход из цикла. Очевидно, что в этой ситуации заранее невозможно узнать, сколько ненулевых значений введет пользователь.
                <br><br>
                <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var counter = 0;
<!-- example -->var a = 1;
<!-- example -->while(a != 0)  // цикл, пока значение counter не равно 0
<!-- example -->    a = +prompt('Введите значение a: ', '');
<!-- example --></code></pre>
                <p>
                    Внешне цикл while напоминает упрощенный вариант цикла for. Он содержит условие для продолжения цикла, но не содержит ни инициализирующих, ни инкрементирующих выражений. Синтаксис цикла while показан на рисунке:
                </p>
<!-- image  --><div class="article-images small-img-5">
<!-- image  -->    <img src="images/while image.jpg" alt="">
<!-- image  --></div>
                <p>
                    До тех пор пока условие продолжения цикла выполняется, исполнение тела цикла продолжается.
                </p>
                <p>
                    На рисунке показан механизм работы цикла while. На самом деле он не так прост, как кажется вначале. Несмотря на отсутствие инициализирующего оператора, нужно инициализировать переменную цикла до начала исполнения тела цикла. Тело цикла должно содержать оператор, изменяющий значение переменной цикла, иначе цикл будет бесконечным.
                </p>
                <h4>5.2.1 Несколько инструкций в теле цикла while</h4>
                <p>
                    Следующий пример, немного модифицированная версия приключенческой игры, демонстрирует применение нескольких инструкций в теле цикла while.Тут мы используем цикл while для непрерывного путешествия:
                <br><br>
                <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var x = 10, y = 10, position = '';
<!-- example -->alert('Введите \'end\' для выхода...');
<!-- example -->while (position != 'end') {
<!-- example -->    alert('Ваши координаты: ' + x + ',' + y);
<!-- example -->    position = prompt('Выберите направление (n, s, e, w): ', '');
<!-- example -->    if (position == 'n') { // движение на север
<!-- example -->        y--;
<!-- example -->        console.log('go north');
<!-- example -->    } else if (position == 's') { // движение на юг
<!-- example -->        y++;
<!-- example -->        console.log('go south');
<!-- example -->    } else if (position == 'e') { // движение на восток
<!-- example -->        x++;
<!-- example -->        console.log('go east');
<!-- example -->    } else if (position == 'w') {  // движение на запад
<!-- example -->        x--;
<!-- example -->        console.log('go west');
<!-- example -->    }           		   
<!-- example -->}
<!-- example --></code></pre>
                <h4>5.3 The do-while Statement/Цикл do...while</h4>
                <p>
                    В цикле while условие продолжения выполнения цикла помещалось в начало цикла. Это означало, что в случае невыполнения условия при первой проверке тело цикла вообще не исполнялось. В некоторых случаях это целесообразно, но возможны и ситуации, когда необходимо выполнить тело цикла хотя бы один раз вне зависимости от истинности проверяемого условия. Для этого следует использовать цикл do, в котором условие продолжения цикла располагается не перед, а после тела цикла.
                </p>
                <p>
                    Большая часть программы находится в составе тела цикла do. Ключевое слово do обозначает начало цикла. Затем, как и в других циклах, следует тело, обрамленное фигурными скобками. Завершает цикл условие продолжения, описываемое с помощью ключевого слова while. Это условие похоже на условие цикла while, но у него есть два отличия: оно располагается в конце цикла и завершается точкой с запятой (;).
                </p>
                <p>
                    Синтаксис цикла do...while показан на рисунке:
                </p>
<!-- image  --><div class="article-images small-img-5">
<!-- image  -->    <img src="images/do while image.jpg" alt="">
<!-- image  --></div>
                <p>
                    <br><br>
                    <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var balance = 100;
<!-- example -->do {
<!-- example -->    alert('Ваш баланс ' + balance + '$');
<!-- example -->    balance -= prompt('Введите сумму, которую вы хотите снять', '0');
<!-- example -->} while (balance > 0);
<!-- example -->alert('Вы потратили все');
<!-- example --></code></pre>
                <h4>5.4 Выбор типа цикла</h4>
                <p>
                    Мы рассмотрели основные аспекты использования циклов. Цикл for подходит для тех случаев, когда мы заранее знаем, сколько раз нам потребуется его выполнение. Циклы while и do используются в тех случаях, когда число итераций цикла заранее не известно, причем цикл while подходит в тех случаях, когда тело цикла может быть не исполненным ни разу, а цикл do — когда обязательно хотя бы однократное исполнение тела цикла. 
                </p>
                <p>
                    Эти критерии достаточно спорны, поскольку выбор типа цикла больше определяется стилем, нежели строго определенными правилами. Каждый из циклов можно применить практически в любой ситуации. При выборе типа цикла стоит руководствоваться удобочитаемостью и легкостью восприятия вашей программы.
                </p>
            </article>
        </section>
<!---   SECTION6      -->
        <section class="clearfix" id="s6">
            <article class="main-article fl">
                <h3>6. Метки. Инструкции перехода: break, continue</h3>
                <p>
                    Еще одной категорией инструкций языка JavaScript являются инструкции перехода. Как следует из названия, эти инструкции заставляют интерпретатор JavaScript переходить в другое место в программном коде. Инструкция <strong>break</strong> заставляет интерпретатор перейти в конец цикла или другой инструкции. Инструкция <strong>continue</strong> заставляет интерпретатор пропустить оставшуюся часть тела цикла, перейти обратно в начало цикла и приступить к выполнению новой итерации. В языке JavaScript имеется возможность помечать инструкции именами, благодаря чему в инструкциях break и continue можно явно указывать, к какому циклу или к какой другой инструкции они относятся.
                </p>
                <p>Подробнее все эти инструкции перехода описываются в следующих подразделах.</p>
                <h4>6.1 Метки(LabelledStatement)</h4>
                <p>
                    Любая инструкция может быть помечена указанным перед ней идентификатором и двоеточием:
                    <br>
                </p>
<!-- example --><pre><code class="javascript">label :
<!-- example -->    statement
<!-- example --></code></pre>
                <p>
                    Помечая инструкцию, вы тем самым даете ей имя. Пометить можно любую инструкцию, однако помечать имеет смысл только инструкции, имеющие тело, такие как циклы и условные инструкции. Присвоив имя циклу, его затем можно использовать в инструкциях break и continue, внутри цикла для выхода из него или для перехода в начало цикла, к следующей итерации. Инструкции break и continue являются единственными инструкциями в языке JavaScript, с которыми можно указывать метки – о них подробнее рассказывается далее в этой главе.
                </p>
                <p><strong>В JavaScript нет оператора(инструкции) goto, вы можете использовать только метки с break или continue.</strong></p>
                <p>
                    <strong>Иден­ти­фи­ка­тор</strong>, используемый в качестве метки инструкции, может быть любым допустимым идентификатором JavaScript, кроме зарезервированного слова. Имена меток отделены от имен переменных и функций, поэтому в качестве меток допускается использовать идентификаторы, совпадающие с именами переменных или функций. Метки инструкций определены только внутри инструкций, к которым они применяются (и, конечно же, внутри вложенных в них инструкций). Вложенные инструкции не могут помечаться теми же идентификаторами, что и вмещающие их инструкции, но две независимые инструкции могут помечаться одинаковыми метками. Помеченные инструкции могут помечаться повторно. То есть любая инструкция может иметь множество меток.
                </p>
                <p class="warning">
                    Избегайте использования меток. Метки редко используются в коде на JavaScript, так как они делают его сложнее в чтении и понимании. Старайтесь использовать вместо них другие конструкции языка, такие как вызовы функций или выбрасывание ошибок.
                </p>
                <h4>6.2 BreakStatement/Инструкция break</h4>
                <p>
                    Существует 2 способа использовать <strong>break</strong>: с меткой и без.
                </p>
                <h4>6.2.1 Инструкция break без метки</h4>
                <p>Инструкция break приводит к немедленному выходу из самого внутреннего цикла или инструкции switch.</p>
                <p>Синтаксис ее прост:</p>
<!-- example --><pre><code class="javascript">break;</code></pre>
                <p>Поскольку инструкция break приводит к выходу из цикла или инструкции switch, такая форма break допустима только внутри этих инструкций.</p>
                <p>
                    Выше мы уже видели примеры использования инструкции break внутри инструкции switch. В циклах она обычно используется для немедленного выхода из цикла, когда по каким-либо причинам требуется завершить выполнение цикла. Когда цикл имеет очень сложное условие завершения, зачастую проще бывает реализовать эти условия с помощью инструкций break, чем пытаться выразить их в одном условном выражении цикла. Следующей инструкцией, исполняемой после break, будет первая инструкция, находящаяся вне данного цикла.
                </p>
                <h4>6.2.2 Инструкция break с меткой</h4>
                <p>
                    Когда инструкция break используется с меткой, она выполняет переход в конец именованной инструкции. В случае отсутствия инструкции с указанной меткой попытка использовать такую форму инструкции break порождает синтаксическую ошибку. Именованная инструкция не обязана быть циклом или инструкцией switch: инструкция break с меткой может выполнять «выход» из любой вмещающей ее инструкции. Объемлющая инструкция может даже быть простым блоком инструкций, заключенным в фигурные скобки исключительно с целью пометить его.
                </p>
                <p>
                    Между ключевым словом break и именем метки не допускается вставлять символ перевода строки. Дело в том, что интерпретатор JavaScript автоматически вставляет пропущенные точки с запятой: если разбить строку программного кода между ключевым словом break и следующей за ним меткой, интерпретатор предположит, что имелась в виду простая форма этой инструкции без метки, и добавит точку с запятой.
                    <br><br>
                    <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->myLabel: {
<!-- example -->    console.log(1);
<!-- example -->    break myLabel;
<!-- example -->    console.log(2);
<!-- example -->}
<!-- example -->console.log(3);
<!-- example --></code></pre>
                <p>
                    <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->outer: for (var i = 0; i &lt; 3; i++) {
<!-- example -->    for (var j = 0; j &lt; 3; j++) {
<!-- example -->        var input = prompt('Значение в координатах ' + i + ', ' + j, '');
<!-- example -->        // если отмена ввода или пустая строка -
<!-- example -->        // завершить оба цикла
<!-- example -->        if (!input) break outer; // (*)
<!-- example -->    }
<!-- example -->}
<!-- example -->alert('Готово!');
<!-- example --></code></pre>
                <p>
                    Инструкция break с меткой на практике необходима, только когда требуется прервать выполнение инструкции, не являющейся ближайшим объемлющим циклом или инструкцией switch.
                </p>
                <p>
                    Наконец, обратите внимание, что инструкция break, с меткой или без нее, не может передавать управление через границы функций. Например, нельзя пометить инструкцию объявления функции и затем использовать эту метку внутри функции.
                </p>
                <h4>6.3 ContinueStatement/Инструкция continue</h4>
                <p>
                    Оператор break производит выход из цикла. Тем не менее, могут возникнуть и такие ситуации, когда необходимо при определенном условии не выходить из цикла, а досрочно возвращаться в его начало. Именно таким эффектом обладает применение оператора <strong>continue</strong> (строго говоря, continue делает переход на завершающую фигурную скобку цикла, откуда производится обычный переход в начало тела цикла).
                </p>
                <p>
                    Синтаксис инструкции continue столь же прост, как и синтаксис инструкции break:
                </p>
<!-- example --><pre><code class="javascript">continue;</code></pre>
                <p>
                    Инструкция continue может также использоваться с меткой:
                </p>
<!-- example --><pre><code class="javascript">continue label;</code></pre>
                <p>Инструкция continue, как в форме без метки, так и с меткой, может использоваться только в теле цикла. Использование ее в любых других местах приводит к синтаксической ошибке.</p>
                <p>
                    Инструкция continue, как и break, может применяться во вложенных циклах в форме, включающей метку, и тогда заново запускаемым циклом необязательно будет цикл, непосредственно содержащий инструкцию continue. Кроме того, как и для инструкции break, переводы строк между ключевым словом continue и именем метки не допускаются.
                </p>
            </article>
        </section>
<!---   SECTION7      -->
        <section class="clearfix" id="s7">
            <article class="main-article fl">
                <h3>7. Логические операции (Binary Logical Operators)</h3>
                <p>
                    В JavaScript есть 3 логических  операции:<br>
                    - || (ИЛИ);<br>
                    - &amp;&amp; (И);<br>
                    - ! (НЕ).<br>
                </p>
                <p>
                    Логические операторы <strong>&amp;&amp;, || и !</strong> используются для выполнения операций булевой алгебры и часто применяются в сочетании с операторами отношений для объединения двух выражений отношений в одно более сложное выражение. Эти операторы описываются ниже. Чтобы понять, как они действуют, вам может потребоваться еще раз прочитать о концепции булевых значений.
                </p>
                <p>
                    Логические операторы используются, как правило, с примитивами Boolean (логического) типа. В этом случае результатом работы оператора является значение логического типа. Между тем операторы &amp;&amp; и || возвращают значение  одного из операнда, потому при использовании в качестве аргументов этих операторов величин, тип которых отличен от Boolean, тип возвращаемого значения может быть отличным от Boolean.
                </p>
                <p><strong>Если значение не логического типа - то в процессе вычислений к нему применяться преобразование к логическому типу.</strong></p>
                <h4>7.1 Логическое И (&amp;&amp;)</h4>
                <p>
                    Оператор И выглядит как два амперсанда (&amp;&amp;).
                </p>
<!-- example --><pre><code class="javascript">operand &amp;&amp; operand;</code></pre>  
                <p>
                    Условно говоря, оператор &amp;&amp; действует на трех уровнях. На самом простом уровне, когда в операции участвуют логические операнды, оператор &amp;&amp; выполняет операцию «логическое И» над двумя значениями: он возвращает true тогда и только тогда, когда оба операнда имеют значение true. Если один или оба операнда имеют значение false, оператор возвращает false.
                </p>
                <p>Оператор &amp;&amp; часто используется для объединения двух выражений отношений:</p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->x == 0 &amp;&amp; y == 0; // true то­гда и толь­ко то­гда, ко­гда x и y рав­ны 0
<!-- example --></code></pre>
                <p>
                    Выражения отношений всегда возвращают значение true или false, поэтому в подобных ситуациях сам оператор &amp;&amp; всегда возвращает true или false. Операторы отношений имеют более высокий приоритет, чем оператор &amp;&amp; (и ||), поэтому такие выражения можно записывать без использования скобок.
                </p>
                <p>
                    Но оператор &amp;&amp; не требует, чтобы его операнды были логическими значениями.
                </p>
                <p>
                    На втором уровне оператор &amp;&amp; действует как логическое И для истинных и ложных значений. Если оба операнда являются истинными, оператор возвращает истинное значение. В противном случае, когда один или оба операнда являются ложными, возвращается ложное значение. В языке JavaScript все выражения и инструкции, использующие логические значения, будут также работать с истинными или ложными значениями, поэтому тот факт, что оператор &amp;&amp; не всегда возвращает true или false, на практике не вызывает никаких проблем.
                </p>
                <p>
                    Обратите внимание, что в предыдущем абзаце говорилось, что оператор возвращает «истинное значение» или «ложное значение», но при этом не уточнялось, какое именно значение возвращается. Для этого нам необходимо перейти на третий, заключительный уровень оператора &amp;&amp;. Свою работу оператор начинает с вычисления первого операнда – выражения слева. Если выражение слева возвращает ложное значение, значением всего выражения также должно быть ложное значение, поэтому оператор &amp;&amp; просто возвращает значение слева и не вычисляет выражение справа.
                </p>
                <p>
                    В противном случае, если значение слева является истинным, тогда результат всего выражения определяется значением справа. Если значение справа является истинным, значением всего выражения также должно быть истинное значение, а если значение справа является ложным, значением всего выражения должно быть ложное значение. Поэтому, когда значение слева является истинным, оператор &amp;&amp; вычисляет и возвращает значение справа:
                    <br><br>
                    <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->// Первый аргумент - true,
<!-- example -->// Поэтому возвращается второй аргумент
<!-- example -->alert( 1 &amp;&amp; 0 ); // 0
<!-- example -->alert( 1 &amp;&amp; 5 ); // 5
<!-- example -->
<!-- example -->// Первый аргумент - false,
<!-- example -->// Он и возвращается, а второй аргумент игнорируется
<!-- example -->alert( null &amp;&amp; 5 ); // null
<!-- example -->alert( 0 &amp;&amp; "не важно" ); // 0
<!-- example --></code></pre>
                <p>
                    Такое поведение оператора &amp;&amp; иногда называют <strong>короткой схемой вычислений </strong>(коротким циклом вычислений), и иногда можно встретить программный код, в котором такое поведение оператора &amp;&amp; используется специально для выполнения инструкций по условию. Например, следующие две строки дают одинаковый результат:
                    <br><br>
                    <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->if (a == b) stop(); // Функ­ция stop() вы­зы­ва­ет­ся, толь­ко ес­ли a == b
<!-- example -->(a == b) &amp;&amp; stop(); // То же са­мое
<!-- example --></code></pre>
                <p>
                    В целом следует с осторожностью использовать выражения с побочными эффектами (присваивания, инкременты, декременты или вызовы функций) справа от оператора &amp;&amp;, потому что эти побочные эффекты будут проявляться в зависимости от значения слева. 
                </p>
                <p>
                    Несмотря на довольно запутанный алгоритм работы этого оператора, проще всего и абсолютно безопасно рассматривать его как оператор булевой алгебры, который манипулирует истинными и ложными значениями.
                    <br><br>
                    <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->a1 = true  &amp;&amp; true;          // t &amp;&amp; t вернёт true
<!-- example -->a2 = true  &amp;&amp; false;         // t &amp;&amp; f вернёт false
<!-- example -->a3 = false &amp;&amp; true;          // f &amp;&amp; t вернёт false
<!-- example -->a4 = false &amp;&amp; (3 == 4);      // f &amp;&amp; f вернёт false
<!-- example -->a5 = "Cat" &amp;&amp; "Dog";         // t &amp;&amp; t вернёт "Dog"
<!-- example -->a6 = false &amp;&amp; "Cat";         // f &amp;&amp; t вернёт false
<!-- example -->a7 = "Cat" &amp;&amp; false;         // t &amp;&amp; f вернёт false
<!-- example --></code></pre>
                <h4>7.2 Логическое ИЛИ (||)</h4>
                <p>
                    Оператор || выполняет операцию «логическое ИЛИ» над двумя операндами. Если один или оба операнда имеют истинное значение, он возвращает истинное значение. Если оба операнда имеют ложные значения, он возвращает ложное значение. 
                </p>
                <p>
                    Хотя оператор || чаще всего применяется просто как оператор «логическое ИЛИ», он, как и оператор &amp;&amp;, ведет себя более сложным образом. Его работа начинается с вычисления первого операнда, выражения слева. Если значение этого операнда является истинным, возвращается истинное значение. В противном случае оператор вычисляет второй операнд, выражение справа, и возвращает значение этого выражения.
                </p>
                <p>
                    Как и при использовании оператора &amp;&amp;, следует избегать правых операндов, имеющих побочные эффекты, если только вы умышленно не хотите воспользоваться тем обстоятельством, что выражение справа может не вычисляться.
                    <br><br>
                    <u>Пример</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->o1 = true  || true;         // t || t вернёт true
<!-- example -->o2 = false || true;         // f || t вернёт true
<!-- example -->o3 = true  || false;        // t || f вернёт true
<!-- example -->o4 = false || (3 == 4);     // f || f вернёт false
<!-- example -->o5 = "Cat" || "Dog";        // t || t вернёт "Cat"
<!-- example -->o6 = false || "Cat";        // f || t вернёт "Cat"
<!-- example -->o7 = "Cat" || false;        // t || f вернёт "Cat"
<!-- example --></code></pre>
                <h4>7.3 Логическое НЕ (!)</h4>
                <p>
                    Оператор ! является унарным оператором, помещаемым перед одиночным операндом. Он используется для инверсии логического значения своего операнда. Например, если переменная x имеет истинное значение, то выражение !x возвращает значение false. Если x имеет ложное значение, то выражение !x возвращает значение false.
                </p>
                <p>
                    В отличие от операторов &amp;&amp; и ||, оператор ! преобразует свой операнд в логическое значение (используя правила преобразование к логическому типу) перед тем, как инвертировать его. Это означает, что <strong>оператор ! всегда возвращает true или false</strong>. Можно преобразовать любое значение x в его логический эквивалент, дважды применив этот оператор: !!x
                </p>
                <p>
                    Будучи унарным, оператор ! имеет высокий приоритет и тесно связан с операндом. Если вам потребуется инвертировать значение выражения, такого как p &amp;&amp; q, необходимо будет использовать круглые скобки: !(p &amp;&amp; q).
                </p>
                <h4>7.4 Использование логических операторов</h4>
                <p>
                    Давайте рассмотрим, каким образом логические операции соединяют булевы выражения в JavaScript. В следующем примере, ADVENand, логическая операция используется для усложнения приключенческой игры. Теперь мы закопаем сокровище в точке с координатами (7, 11) и попробуем заставить нашего героя отыскать его.
                    <br><br>
                    <u>Пример ADVENand</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var x = 10, y = 10, position = '';
<!-- example -->alert('Введите \'end\' для выхода...');
<!-- example -->while (true) {
<!-- example -->    alert('Ваши координаты: ' + x + ',' + y);
<!-- example -->    position = prompt('Выберите направление (n, s, e, w): ', '');
<!-- example -->
<!-- example -->    if (position == 'end') break;
<!-- example -->
<!-- example -->    if (position == 'n') { // движение на север
<!-- example -->        y--;
<!-- example -->        console.log('go north');
<!-- example -->    } else if (position == 's') { // движение на юг
<!-- example -->        y++;
<!-- example -->        console.log('go south');
<!-- example -->    } else if (position == 'e') { // движение на восток
<!-- example -->        x++;
<!-- example -->        console.log('go east');
<!-- example -->    } else if (position == 'w') {  // движение на запад
<!-- example -->        x--;
<!-- example -->        console.log('go west');
<!-- example -->    }
<!-- example -->
<!-- example -->    if (x == 7 &amp;&amp; y == 11) {
<!-- example -->        alert('Вы нашли сокровище');
<!-- example -->    }        		   
<!-- example -->}
<!-- example --></code></pre>
                <p>
                    Если игрок попадет в точку, где находится сокровище, программа отреагирует на это.
                </p>
                <p>
                    Введем в нашу приключенческую игру новых персонажей — драконов, которые будут обитать на западных и восточных землях и ограничат свободное передвижение нашего героя. Следующая программа, ADVENor, с помощью операции логического ИЛИ реализует нашу задумку:
                    <br><br>
                    <u>Пример ADVENor</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var x = 10, y = 10, position = '';
<!-- example -->alert('Введите \'end\' для выхода...');
<!-- example -->while (true) {
<!-- example -->    alert('Ваши координаты: ' + x + ',' + y);
<!-- example -->    position = prompt('Выберите направление (n, s, e, w): ', '');
<!-- example -->
<!-- example -->    if (position == 'end') break;
<!-- example -->
<!-- example -->    if (position == 'n') { // движение на север
<!-- example -->        y--;
<!-- example -->        console.log('go north');
<!-- example -->    } else if (position == 's') { // движение на юг
<!-- example -->        y++;
<!-- example -->        console.log('go south');
<!-- example -->    } else if (position == 'e') { // движение на восток
<!-- example -->        x++;
<!-- example -->        console.log('go east');
<!-- example -->    } else if (position == 'w') {  // движение на запад
<!-- example -->        x--;
<!-- example -->        console.log('go west');
<!-- example -->    }
<!-- example -->
<!-- example -->    if (x == 7 &amp;&amp; y == 11) {
<!-- example -->        alert('Вы нашли сокровище');
<!-- example -->    }
<!-- example -->    if (x &lt;= 5 ||  x >= 15) {
<!-- example -->        alert('Осторожно - драконы!');
<!-- example -->    }        	        		   
<!-- example -->}
<!-- example --></code></pre>
            </article>
        </section>
<!---   SECTION8      -->
        <section class="clearfix" id="s8">
            <article class="main-article fl">
            <h3>8. Резюме</h3>
            <p>Операция отношения сравнивает между собой два значения. Сравнение устанавливает одно из четырех возможных отношений между переменными: больше, меньше, равенство(эквивалентность), строгое равенство(идентичность).</p>
            <p>Результатом сравнения является значение истина или ложь. Например, две величины могут быть равны (истина) или не равны (ложь).</p>
            <p>
                В JavaScript существует несколько типов ветвлений, наиболее важным из которых является if...else, осуществляющее выбор между двумя альтернативами. В инструкции ветвления if...else использование else не является обязательным. Для выбора одной из множества альтернатив используется     инструкция ветвления switch, действие которого определяется набором значений соответствующей переменной. Кроме того, существует так называемая условная операция, используемая внекоторых особых ситуациях.
            </p>
            <p>Объект Math является встроенным объектом, хранящим в своих свойствах и методах различные математические константы и функции.</p>
            <p>Действие циклов заключается в последовательном повторении определенной части вашей программы некоторое количество раз.</p>
            <p>В JavaScript существует 5 типов циклов.</p>
            <p>Выбор типа цикла больше определяется стилем, нежели строго определенными правилами. Каждый из циклов можно применить практически в любой ситуации. При выборе типа цикла стоит руководствоваться удобочитаемостью и легкостью восприятия вашей программы.</p>
            <p>Инструкция break заставляет интерпретатор перейти в конец цикла или другой инструкции. Инструкция continue заставляет интерпретатор пропустить оставшуюся часть тела цикла, перейти обратно в начало цикла и приступить к выполнению новой итерации.</p>
            <p>Логические операторы &amp;&amp;, || и ! используются для выполнения операций булевой алгебры и часто применяются в сочетании с операторами отношений для объединения двух выражений отношений в одно более сложное выражение.</p>
            <p>
                Логические операторы используются, как правило, с примитивами логического типа. В этом случае результатом работы оператора является значение логического типа. Между тем операторы &amp;&amp; и || возвращают значение  одного из операнда, потому при использовании в качестве аргументов этих     операторов величин, тип которых отличен от логического, тип возвращаемого значения может быть отличным от Boolean.
            </p>
            </article>
        </section>
    </main>
    <footer></footer>
</div>
<script src="../js/highlight.pack.js"></script>
<script src="../js/highlightjs-line-numbers.js"></script>
<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>
<script src="../js/main.js"></script>
</body>
</html>

<!--
    <div class="article-images">
        <img src="images/web publishing.png" alt="">
    </div>
-->
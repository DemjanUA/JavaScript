<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Lesson №8.2 | Структуры данных: массивы</title>
    <link rel="shortcut icon" href="../images/logo.ico">
    <link rel="stylesheet" href="../css/main.css">
    <!--Fonts-->
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,500,500i,700,700i" rel="stylesheet">

    <link rel="stylesheet" href="../css/atom-one-dark.css">
</head>
<body>
<div class="wrapper">
    <header>
        <a href="/" class="logo">
         <img src="../images/logo.svg" alt="logotype">
        </a>
    </header>
    <main>
        <h1 class="title">Структуры данных: массивы</h1>
        <h3 class="content-list">Содержание</h3>
        <ul class="plan">
            <li><a href="#s1">Вступление</a></li>
            <li><a href="#s2">Объекты как ассоциативные массивы</a></li>
            <li><a href="#s3">Массивы с числовыми индексами</a></li>
            <li><a href="#s4">Создание массивов</a></li>
            <li><a href="#s5">Доступ к элементам массива</a></li>
            <li><a href="#s6">Длина массива</a></li>
            <li><a href="#s7">Добавление и удаление элементов массива</a></li>
            <li><a href="#s8">Методы класса Array</a></li>
            <li><a href="#s*">Упражнения</a></li>
        </ul>
<!---   SECTION1      -->
        <section class="clearfix" id="s1">
            <article class="main-article fl">
                <h3>1. Вступление</h3>
                <p>
                    Массив – это упорядоченная коллекция значений. Значения в массиве называются элементами, и каждый элемент характеризуется числовой позицией (или строкой если речь идет о ассоциативных массивах) в массиве, которая называется индексом (ключ для ассоциативных). Массивы в языке JavaScript являются нети­пизированными: элементы массива могут иметь любой тип, причем разные элементы одного и того же массива могут иметь разные типы. Элементы массива могут даже быть объектами или другими массивами, что позволяет создавать сложные структуры данных, такие как массивы объектов и массивы массивов.
                </p>
                <p>
                    В JavaScript есть 2 типа массивов: ассоциативные массивы и массивы с числовыми индексами.
                </p>
                <p>
                    Ассоциативные массивы в JavaScript это не отдельный тип коллекции, а всего лишь объекты без методов. То есть если объект хранит данные и не делает с ними никаких действий это ассоциативный массив.
                </p>
                <p>
                    В отличии от ассоциативных массивов, массивы с числовыми индексами в JavaScript считаются отдельной кастой (говорят подкласом) обычных объектов. Но не образуют отдельного типа данных как в других языках програмирования.
                </p>
            </article>
        </section>
<!---   SECTION2      -->
        <section class="clearfix" id="s2">
            <article class="main-article fl">
                <h3>2. Объекты как ассоциативные массивы</h3>
                <p>
                     В этой главе мы рассмотрим использование объектов именно как массивов.
                </p>
                <p><strong>Ассоциативные массивы</strong> - структура данных, в которой можно хранить любые данные в формате ключ-значение.</p>
                <p>Именно синтаксис доступа к полям объекта через квадратные скобки делает их похожими на ассоциативные массивы других языков програмирования.</p>
                <p>
                    Так как ассоциативные массивы это просто объекты, все методики работы с объектами справедливы и к ассоциативным массивам.
                </p>
                <p>
                    Могут закрасться сомнения нужно ли вводить такой термин как ассоциативные массивы, для JS колекций если это всего лишь объекты, но стоит знать что ассоциативные массивы имеют некие механизмы оптимизации, что приводит к отличиям реализаций таких структур на уровне памяти. А именно ассоциативные массивы поддерживают механизм <a href="https://learn.javascript.ru/object#компактное-представление-объектов">компактного представления в памяти</a>.
                </p>
            </article>
        </section>
<!---   SECTION3      -->
        <section class="clearfix" id="s3">
            <article class="main-article fl">
                <h3>3. Массивы с числовыми индексами</h3>
                <p>
                     В этой главе мы рассмотрим использование подкласса Array - что реализовывает массивы с числовыми индексами в JavaScript.
                </p>
                <p>
                    С этого момента и в будущем массивы с числовыми индексами мы будем называть просто массивами.
                </p>
                <p>
                    <strong>Массив</strong> – разновидность объекта, которая предназначена для хранения пронумерованных значений и предлагает дополнительные методы для удобного манипулирования такой коллекцией.
                </p>
                <p>
                    Отсчет индексов массивов в языке JavaScript начинается с нуля и для них используются 32-битные целые числа: первый элемент массива имеет индекс 0, а наибольший возможный индекс имеет значение 4294967295 элементов.
                </p>
            </article>
        </section>
<!---   SECTION4      -->
        <section class="clearfix" id="s4">
            <article class="main-article fl">
                <h3>4. Создание массивов</h3>
                <p>
                     Легче всего создать массив с помощью литерала, который представляет собой простой список разделенных запятыми элементов массива в квадратных скобках.
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var empty = []; // Пус­той мас­сив
<!-- example -->var primes = [2, 3, 5, 7, 11]; // Мас­сив с пя­тью чи­сло­вы­ми эле­мен­та­ми
<!-- example -->var misc = [ 1.1, true, "a" ]; // 3 эле­мен­та раз­ных ти­пов 
<!-- example --></code></pre>
                <p>
                    Значения в литерале массива не обязательно должны быть константами – это могут быть любые выражения:
                </p>                
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var base = 1024;
<!-- example -->var table = [base, base+1, base+2, base+3];
<!-- example --></code></pre>
                <p>
                    Литералы массивов могут содержать литералы объектов или литералы других массивов:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var b = [[1,{x:1, y:2}], [2, {x:3, y:4}]];
<!-- example --></code></pre>
                <p>
                    Другой способ создания массива состоит в вызове конструктора Array(). Вызвать конструктор можно тремя разными способами:
                </p>              
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->// Вызвать конструктор без аргументов:
<!-- example -->var a = new Array();
<!-- example --></code></pre>
                <p>
                    В этом случае будет создан пустой массив, эквивалентный литералу [].
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->// Вызвать конструктор с единственным числовым аргументом,
<!-- example -->// определяющим длину массива:
<!-- example -->var a = new Array(10);
<!-- example --></code></pre>
                <p>
                    В этом случае будет создан пустой массив указанной длины. Такая форма вызова конструктора Array() может использоваться для предварительного распределения памяти под массив, если заранее известно количество его элементов. Обратите внимание, что при этом в массиве не сохраняется никаких значений и даже свойства-индексы массива с именами «0», «1» и т.д. в массиве не определены.
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->// Явно указать в вызове конструктора значения первых двух или более 
<!-- example -->// элементов массива или один нечисловой элемент:
<!-- example -->var a = new Array(5, 4, 3, 2, 1, "testing, testing");
<!-- example --></code></pre>
                <p>
                    В этом случае аргументы конструктора становятся значениями элементов нового массива. Использование литералов массивов практически всегда проще, чем подобное применение конструктора Array().
                </p>
            </article>
        </section>
<!---   SECTION5      -->
        <section class="clearfix" id="s5">
            <article class="main-article fl">
                <h3>5. Доступ к элементам массива</h3>
                <p>
                    Доступ к элементам массива осуществляется с помощью оператора [ ]. Слева от скобок должна присутствовать ссылка на массив. Внутри скобок должно находиться произвольное выражение, возвращающее неотрицательное целое значение. Этот синтаксис пригоден как для чтения, так и для записи значения элемента массива. Следовательно, допустимы все приведенные далее JavaScript-инструкции:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var a = ["world"]; // Соз­дать мас­сив с од­ним эле­мен­том
<!-- example -->var value = a[0]; // Про­чи­тать эле­мент 0
<!-- example -->a[1] = 3.14; // За­пи­сать зна­че­ние в эле­мент 1
<!-- example -->var i = 2;
<!-- example -->a[i] = 3; // За­пи­сать зна­че­ние в эле­мент 2
<!-- example -->a[i + 1] = "hello"; // За­пи­сать зна­че­ние в эле­мент 3
<!-- example -->a[a[i]] = a[0]; // Про­чи­тать эле­мен­ты 0 и 2, за­пи­сать зна­че­ние в эле­мент 3
<!-- example --></code></pre>
                <p>
                    Напомню, что массивы являются специализированной разновидностью объектов. Квадратные скобки, используемые для доступа к элементам массива, действуют точно так же, как квадратные скобки, используемые для доступа к свойствам объекта. Интерпретатор JavaScript преобразует указанные в скобках числовые индексы в строки – индекс 1 превращается в строку "1", – а затем использует строки как имена свойств. В преобразовании числовых индексов в строки нет ничего особенного: то же самое можно проделывать с обычными объектами.
                </p>
            </article>
        </section>
<!---   SECTION6      -->
        <section class="clearfix" id="s6">
            <article class="main-article fl">
                <h3>6. Длина массива</h3>
                <p>
                    Любой массив имеет свойство length, и это свойство отличает массивы от обычных объектов JavaScript. Для плотных (т. е. неразреженных) массивов свойство length определяет количество элементов в массиве. Его значение на единицу больше самого большого индекса в массиве:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
[].length // => 0: мас­сив не име­ет эле­мен­тов
['a','b','c'].length // => 3: наи­боль­ший ин­декс ра­вен 2, дли­на рав­на 3
<!-- example --></code></pre>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var a = [1, 2, 3]
<!-- example -->console.log(a.length);
<!-- example -->delete a[1];
<!-- example -->console.log(a.length);
<!-- example -->a[999] = '';
<!-- example -->console.log(a.length);
<!-- example --></code></pre>
                <p>
                    Вторая особенность в поведении, обеспечивающем работу свойства length, заключается в том, что при присваивании свойству length неотрицательного целого числа n, меньшего, чем его текущее значение, все элементы массива с индексами, большими или равными значению n, удаляются из массива:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var a = [1, 2, 3];
<!-- example -->a.length = 2;
<!-- example -->console.log(a); // [1, 2]
<!-- example --></code></pre>
            </article>
        </section>
<!---   SECTION7      -->
        <section class="clearfix" id="s7">
            <article class="main-article fl">
                <h3>7. Добавление и удаление элементов массива</h3>
                <p>
                    Мы уже видели, что самый простой способ добавить элементы в массив заключается в том, чтобы присвоить значения новым индексам:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->a = [] // Соз­дать пус­той мас­сив.
<!-- example -->a[0] = "zero"; // И до­ба­вить эле­мен­ты.
<!-- example -->a[1] = "one";
<!-- example --></code></pre>
            </article>
        </section>
<!---   SECTION8      -->
        <section class="clearfix" id="s8">
            <article class="main-article fl">
                <h3>8. Методы класса Array</h3>
                <p>
                    Стандарты ECMAScript3-6 определяеют в составе Array.prototype множество удобных функций для работы с массивами, которые доступны как методы любого массива. Эти методы будут представлены в следующих подразделах. Более полную информацию можно найти в разделе Array в справочной части <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array">MDN</a> по базовому языку JavaScript. 
                </p>
                <h4>8.1 ES3</h4>
                <h4>8.1.1 Метод join()</h4>
                <p>
                    Метод Array.join() преобразует все элементы массива в строки, объединяет их и возвращает получившуюся строку. В необязательном аргументе методу можно передать строку, которая будет использоваться для отделения элементов в строке результата. Если строка-разделитель не указана, используется запятая.
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var arr = ['Маша', 'Петя', 'Марина', 'Василий'];
<!-- example -->var str = arr.join(';');
<!-- example -->alert( str ); // Маша;Петя;Марина;Василий
<!-- example -->alert(typeof str); // "string"
<!-- example -->
<!-- example -->var str = arr.join();
<!-- example -->alert( str ); // Маша,Петя,Марина,Василий
<!-- example -->
<!-- example -->var str = arr.join(', ');
<!-- example -->alert( str ); // Маша, Петя, Марина, Василий
<!-- example --></code></pre>
                <h4>8.1.2 Метод reverse()</h4>
                <p>
                    Метод Array.reverse() меняет порядок следования элементов в массиве на обратный и возвращает переупорядоченный массив. Перестановка выполняется непосредственно в исходном массиве, т. е. этот метод не создает новый массив с переупорядоченными элементами, а переупорядочивает их в уже существующем массиве.
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var arr = ['Маша', 'Петя', 'Марина', 'Василий'];
<!-- example -->arr.reverse();
<!-- example -->console.log(arr); // ["Василий", "Марина", "Петя", "Маша"]
<!-- example --></code></pre>
                <h4>8.1.3 Метод split()</h4>
                <p>
                    Метод split(s), который позволяет превратить строку в массив, разбив ее по разделителю s. В примере ниже таким разделителем является строка из запятой и пробела.
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var names = 'Маша, Петя, Марина, Василий';
<!-- example -->
<!-- example -->var arr = names.split(', ');
<!-- example -->
<!-- example -->for (var i = 0; i < arr.length; i++) {
<!-- example -->  alert( 'Вам сообщение ' + arr[i] );
<!-- example -->}
<!-- example --></code></pre>
                <p>У метода split есть необязательный второй аргумент – ограничение на количество элементов в массиве. Если их больше, чем указано – остаток массива будет отброшен.</p>
                <h4>8.1.4 Метод slice()</h4>
                <p>
                    Метод Array.slice() возвращает фрагмент, или подмассив, указанного массива. Два аргумента метода определяют начало и конец возвращаемого фрагмента. Возвращаемый массив содержит элемент, номер которого указан в первом аргументе, плюс все последующие элементы, вплоть до (но не включая) элемента, номер которого указан во втором аргументе. Если указан только один аргумент, возвращаемый массив содержит все элементы от начальной позиции до конца массива. Если какой-либо из аргументов имеет отрицательное значение, он определяет номер элемента относительно конца массива. Так, аргументу –1 соответствует последний элемент массива, а аргументу –3 – третий элемент массива с конца.
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var arr = ['Маша', 'Петя', 'Марина', 'Василий'];
<!-- example -->var part = arr.slice(1, 3); // ["Петя", "Марина"]
<!-- example --></code></pre>
                <p>
                    Если вообще не указать аргументов – скопируется весь массив.
                </p>
                <h4>8.1.5 Метод splice()</h4>
                <p>
                    Метод Array.splice() – это универсальный метод, выполняющий вставку или удаление элементов массива. Метод splice() изменяет исходный массив, относительно которого он был вызван. Обратите внимание, что методы splice() и slice() имеют очень похожие имена, но выполняют совершенно разные операции.
                </p>
                <p>
                    Метод splice() может удалять элементы из массива, вставлять новые элементы или выполнять обе операции одновременно. Элементы массива при необходимости смещаются, чтобы после вставки или удаления образовывалась непрерывная последовательность. Первый аргумент метода splice() определяет позицию в массиве, начиная с которой будет выполняться вставка и/или удаление. Второй аргумент определяет количество элементов, которые должны быть удалены (вырезаны) из массива. Если второй аргумент опущен, удаляются все элементы массива от указанного до конца массива. Метод splice() возвращает массив удаленных элементов или (если ни один из элементов не был удален) пустой массив.
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var a = [1,2,3,4,5,6,7,8];
<!-- example -->a.splice(4); // Вер­нет [5,6,7,8]; a = [1,2,3,4]
<!-- example -->a.splice(1,2); // Вер­нет [2,3]; a = [1,4]
<!-- example -->a.splice(1,1); // Вер­нет [4]; a = [1]
<!-- example --></code></pre>
                <p>
                    Первые два аргумента метода splice() определяют элементы массива, подлежащие удалению. За этими аргументами может следовать любое количество дополнительных аргументов, определяющих элементы, которые будут вставлены в массив, начиная с позиции, указанной в первом аргументе. Например:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var a = [1,2,3,4,5];
<!-- example -->a.splice(2,0,'a','b'); // Вер­нет []; a = [1,2,'a','b',3,4,5]
<!-- example -->a.splice(2,2,[1,2],3); // Вер­нет ['a','b']; a = [1,2,[1,2],3,3,4,5]
<!-- example --></code></pre>
                <h4>8.1.6 Метод concat()</h4>
                <p>
                    Метод Array.concat() создает и возвращает новый массив, содержащий элементы исходного массива, для которого был вызван метод concat(), и значения всех аргументов, переданных методу concat(). Если какой-либо из этих аргументов самявляется массивом, его элементы добавляются в возвращаемый массив. Следует, однако, отметить, что рекурсивного превращения массива из массивов в одно мерный массив не происходит. Метод concat() не изменяет исходный массив. Ниже приводится несколько примеров:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var a = [1,2,3];
<!-- example -->a.concat(4, 5) // Вер­нет [1,2,3,4,5]
<!-- example -->a.concat([4,5]); // Вер­нет [1,2,3,4,5]
<!-- example -->a.concat([4,5],[6,7]) // Вер­нет [1,2,3,4,5,6,7]
<!-- example -->a.concat(4, [5,[6,7]]) // Вер­нет [1,2,3,4,5,[6,7]]
<!-- example --></code></pre>
                <h4>8.1.7 Метод sort()</h4>
                <p>
                    Метод Array.sort() сортирует элементы в исходном массиве и возвращает отсортированный массив. Если метод sort() вызывается без аргументов, сортировка выполняется в алфавитном порядке (для сравнения элементы временно преобразуются в строки, если это необходимо).
                </p>
                <p>
                    Для сортировки в каком-либо ином порядке, отличном от алфавитного, методу sort() можно передать функцию сравнения в качестве аргумента. Эта функция устанавливает, какой из двух ее аргументов должен следовать раньше в отсортированном списке. Если первый аргумент должен предшествовать второму, функция сравнения должна возвращать отрицательное число. Если первый аргумент должен следовать за вторым в отсортированном массиве, то функция должна возвращать число больше нуля. А если два значения эквивалентны (т.е. порядок их следования не важен), функция сравнения должна возвращать 0. Поэтому, например, для сортировки элементов массива в числовом порядке можно сделать следующее:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var a = [33, 4, 1111, 222];
<!-- example -->a.sort(); // Ал­фа­вит­ный по­ря­док: 1111, 222, 33, 4
<!-- example -->a.sort(function(a,b) { // Чи­сло­вой по­ря­док: 4, 33, 222, 1111
<!-- example --> return a-b; // Воз­вра­ща­ет зна­че­ние < 0, 0 или > 0
<!-- example --> }); // в за­ви­си­мо­сти от по­ряд­ка сор­ти­ров­ки a и b
<!-- example -->a.sort(function(a,b) {return b-a}); // Обратный числовой порядок
<!-- example --></code></pre>
                <p>
                    Обратите внимание, насколько удобно использовать в этом фрагменте неименованную функцию. Функция сравнения используется только здесь, поэтому нет необходимости давать ей имя.
                </p>
                <h4>8.2 ES5</h4>
                <p>
                    Стандарт ECMAScript 5 определяет девять новых методов массивов, позволяющих выполнять итерации, отображение, фильтрацию, проверку, свертку и поиск. Все эти методы описываются в следующих далее подразделах.
                </p>
                <p>
                    Однако, прежде чем перейти к изучению особенностей, следует сделать некоторые обобщения, касающиеся методов массивов в ECMAScript 5. Во-первых, большинство описываемых ниже методов принимают функцию в первом аргументе и вызывают ее для каждого элемента (или нескольких элементов) массива. В случае разреженных массивов указанная функция не будет вызываться для несуществующих элементов. В большинстве случаев указанной функции передаются три аргумента: значение элемента массива, индекс элемента и сам массив. Чаще всего вам необходим будет только первый аргумент, а второй и третий аргументы можно просто игнорировать. Большинство методов массивов, введенных стандартом ECMAScript 5, которые в первом аргументе принимают функцию, также принимают второй необязательный аргумент. Если он указан, функция будет вызываться, как если бы она была методом этого второго аргумента. То есть второй аргумент будет доступен функции, как значение ключевого слова this. Значение, возвращаемое функцией, играет важную роль, но разные методы обрабатывают его по-разному. Ни один из методов массивов, введенных стандартом ECMAScript 5, не изменяет исходный массив. Разумеется, функция, передаваемая этим методам, может модифицировать исходный массив.
                </p>
                <h4>8.2.1 Метод forEach()</h4>
                <p>
                    Метод forEach() выполняет обход элементов массива и для каждого из них вызывает указанную функцию. Как уже говорилось выше, функция передается методу forEach() в первом аргументе. При вызове этой функции метод forEach() будет передавать ей три аргумента: значение элемента массива, индекс элемента и сам массив. Если вас интересует только значение элемента, можно написать функцию с одним параметром – дополнительные аргументы будут игнорироваться:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var data = [1,2,3,4,5]; // Мас­сив, эле­мен­ты ко­то­ро­го бу­дут сум­ми­ро­вать­ся
<!-- example -->// Най­ти сум­му эле­мен­тов мас­си­ва
<!-- example -->var sum = 0; // На­чаль­ное зна­че­ние сум­мы 0
<!-- example -->data.forEach(function(value) { sum += value; }); // При­ба­вить зна­че­ние к sum
<!-- example -->sum // => 15
<!-- example -->// Уве­ли­чить все эле­мен­ты мас­си­ва на 1
<!-- example -->data.forEach(function(v, i, a) { a[i] = v + 1; });
<!-- example --></code></pre>
                <h4>8.2.2 Метод map()</h4>
                <p>
                    Метод map() создаёт новый массив с результатом вызова указанной функции для каждого элемента массива.
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var numbers = [1, 4, 9];
<!-- example -->var roots = numbers.map(Math.sqrt);
<!-- example -->// теперь roots равен [1, 2, 3], а numbers всё ещё равен [1, 4, 9]
<!-- example --></code></pre>
                <h4>8.2.3 Метод filter()</h4>
                <p>
                    Метод filter() возвращает массив, содержащий подмножество элементов исходного массива. Передаваемая ему функция должна быть функцией-предикатом, т. е. должна возвращать значение true или false. Метод filter() вызывает функцию точно так же, как методы forEach() и map(). Если возвращается true или значение, которое может быть преобразовано в true, переданный функции элемент считается членом подмножества и добавляется в массив, возвращаемый методом. Например:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->a = [5, 4, 3, 2, 1];
<!-- example -->smallvalues = a.filter(function(x) { return x < 3 }); // [2, 1]
<!-- example -->everyother = a.filter(function(x,i) { return i%2==0 }); // [5, 3, 1]
<!-- example --></code></pre>
                <p>
                    Обратите внимание, что метод filter() пропускает отсутствующие элементы в разреженных массивах и всегда возвращает плотные массивы. Чтобы уплотнить разреженный массив, можно выполнить следующие действия: 
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var dense = sparse.filter(function() { return true; });
<!-- example --></code></pre>
                <p>
                    А чтобы уплотнить массив и удалить из него все элементы со значениями undefined и null, можно использовать метод filter(), как показано ниже:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->a = a.filter(function(x) { return x !== undefined &amp;&amp; x != null; });
<!-- example --></code></pre>
                <h4>8.2.3 Методы every() и some()</h4>
                <p>
                    Метод <strong>some()</strong> проверяет, удовлетворяет ли хоть какой-нибудь элемент массива условию, заданному в передаваемой функции.
                </p>
                <p>
                    Метод some() вызывает переданную функцию callback один раз для каждого элемента, присутствующего в массиве до тех пор, пока не найдет такой, для которого callback вернет истинное значение (значение, становящееся равным true при приведении его к типу Boolean). Если такой элемент найден, метод some() немедленно вернёт true. В противном случае, если callback вернёт false для всех элементов массива, метод some() вернёт false. Функция callback вызывается только для индексов массива, имеющих присвоенные значения; она не вызывается для индексов, которые были удалены или которым значения никогда не присваивались.
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->function isBiggerThan10(element, index, array) {
<!-- example -->  return element > 10;
<!-- example -->}
<!-- example -->[2, 5, 8, 1, 4].some(isBiggerThan10);  // false
<!-- example -->[12, 5, 8, 1, 4].some(isBiggerThan10); // true
<!-- example --></code></pre>
                <p>
                    Метод <strong>every()</strong> проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции.
                </p>
                <p>
                    Метод every() вызывает переданную функцию callback один раз для каждого элемента, присутствующего в массиве до тех пор, пока не найдет такой, для которого callback вернет ложное значение (значение, становящееся равным false при приведении его к типу Boolean). Если такой элемент найден, метод every() немедленно вернёт false. В противном случае, если callback вернёт true для всех элементов массива, метод every() вернёт true. Функция callback вызывается только для индексов массива, имеющих присвоенные значения; она не вызывается для индексов, которые были удалены или которым значения никогда не присваивались.
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->function isBigEnough(element, index, array) {
<!-- example -->  return element >= 10;
<!-- example -->}
<!-- example -->[12, 5, 8, 130, 44].every(isBigEnough);   // false
<!-- example -->[12, 54, 18, 130, 44].every(isBigEnough); // true
<!-- example --></code></pre>
                <h4>8.2.4 Методы reduce() и reduceRight()</h4>
                <h4>8.2.5 Методы indexOf() и lastIndexOf()</h4>
                <p>
                    Методы indexOf() и lastIndexOf() отыскивают в массиве элемент с указанным значением и возвращают индекс первого найденного элемента или –1, если элемент с таким значением отсутствует. Метод indexOf() выполняет поиск от начала массива к концу, а метод lastIndexOf() – от конца к началу.
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->a = [0,1,2,1,0];
<!-- example -->a.indexOf(1) // => 1: a[1] = 1
<!-- example -->a.lastIndexOf(1) // => 3: a[3] = 1
<!-- example -->a.indexOf(3) // => -1: нет эле­мен­та со зна­че­ни­ем 3
<!-- example --></code></pre>
                <p>
                    В отличие от других методов, описанных в этом разделе, методы indexOf() и lastIndexOf() не принимают функцию в виде аргумента. В первом аргументе им передается искомое значение. Второй аргумент является необязательным: он определяет индекс массива, с которого следует начинать поиск. Если опустить этот аргумент, метод indexOf() начнет поиск с начала массива, а метод lastIndexOf() – с конца. Во втором аргументе допускается передавать отрицательные значения, которые интерпретируются как смещение относительно конца массива, как в методе splice(): значение –1, например, соответствует последнему элементу массива.
                </p>
                <h4>8.3 ES6</h4>
                <h4>8.3.1 Методы find()</h4>
                <h4>8.3.2 Методы findIndex()</h4>
                <h4>8.3.3 Методы fill</h4>
                <h4>8.3.4 Методы copyWithin()</h4>
            </article>
        </section>
<!---   SECTION*      -->
        <section class="clearfix" id="s*">
            <article class="main-article fl">
                <h3>*. Упражнения</h3>
                <h4>1. compareFunctionNumber</h4>
                <p>Напишите функцию compareFunctionNumber(a, b), которая принимает 2 аргумента и возвращает true если первый больше второго и false в ином случае. Приводить к числу оба аргумента внутри функции.</p>
                <h4>2. compareFunctionString</h4>
                <p>Напишите функцию compareFunctionString(a, b), которая сравнивает строки, принимает 2 аргумента и возвращает true если первый больше второго и false в ином случае. Если тип одного из аргументов не строка, возвращать false.</p>
                <h4>3. compareFunctionString</h4>
                <p>Напишите функцию compareFunctionType(a, type), которая принимает 2 аргумента (первый - значение, второй - строка из типом или подтипом) и возвращает true если первый принадлежит к типу второго, false в ином случае.</p>
                <p>Список типов и подтипов, которые должна обрабатывать функция:</br>
                    - undefined</br>
                    - null</br>
                    - Number</br>
                    - NaN</br>
                    - Infinity</br>
                    - String</br>
                    - Boolean</br>
                    - Object</br>
                    - Array</br>
                    - Function
                </p>
                <p>
                    Обратите внимание: строка 'Function', 'function', 'functiOn' должны обрабатываться одинаково (опускаем значения аргумента type в нижний регистр).
                </p>
                <h4>4. singleExemplar</h4>
                <p>Напишите функцию singleExemplar(a), которая принимает 1 аргумент (массив, реализовать безопасность типов) и возвращает новый массив, где все элементы уникальны в пространстве массива.</p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->singleExemplar(a) { .. }
<!-- example -->var myArray = [null, 1, 2, 2, 3, [1, 2], NaN, 'str', '1', {1}, null, NaN, 1, 3];
<!-- example -->singleExemplar(singleExemplar); // [null, 1, 2, 3, [1, 2], NaN, 'str', '1', {1}]
<!-- example --></code></pre>
                <p>Помните: NaN не равен ничему включая себя.</p>
                <h4>5. singleExemplarStrict</h4>
                <p>Напишите функцию singleExemplarStrict(a), которая принимает 1 аргумент (массив, реализовать безопасность типов) и возвращает новый массив, где все элементы уникальны в пространстве массива.</p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->singleExemplar(a) { .. }
<!-- example -->var myArray = [null, 1, 2, 2, 3, [1, 2], [1, 2, 3], [1, 2, 4], [1, 2, 3]];
<!-- example -->singleExemplar(singleExemplar); // [null, 1, 2, 3, [1, 2], [1, 2, 3], [1, 2, 4]]
<!-- example --></code></pre>
                <p>singleExemplar и singleExemplarStrict работают с примитивами работают аналогично. Но singleExemplarStrict считает массивы одинаковими если: 1 - их длины одинаковые, 2 - под одинаковыми индексами стоят одинаковые значения. В контексте функции singleExemplarStrict объекты одинаковые если: 1 - у них одинаковое количество ключей</p>
                <h4>6. nodeList</h4>
                <p>
                    var list = document.querySelectorAll('*'); - магическая строка создаст переменную list и запишет в нее объект со всеми тегами страницы.
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var list = document.querySelectorAll('*');
<!-- example --></code></pre>
                <p>6.1 Создайте массив arrList из элементов объекта list.</p>
                <p>6.2 Создайте строку из названий всех тегов html-элементов - nodeName, используя Array.prototype.join().</p>
                <p>6.3 Создайте строку из названий всех тегов через разделитель, используя Array.prototype.join().</p>
                <p>6.4 Отсортируйте массив arrList от функций, используя sort().</p>
                <p class="warning">
                    Для корректной работы метода sort() всем элементам масива arrList нужно изменить свойство:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->// Example
<!-- example -->var arrList = [{x : 1}, {x : 3}, {x : 4}, {x : 2}];
<!-- example -->arrList.forEach((e) => {
<!-- example -->	e.toString = function() {
<!-- example -->		return this;
<!-- example -->	};
<!-- example -->});
<!-- example --></code></pre>
                <p>6.5 Отсортируйте элементы массива arrList по названию тега в алфавитном порядке.</p>
                <p>6.6 Отсортируйте элементы массива массиа arrList по названию тега в обратном от задания №5 порядке (не используя Array.reverse()), результат сохранить в arrListReverse.</p>
                <p>6.7 Заданние №6 используя Array.reverse().</p>
                <p>6.8 Lorem ipsum dolor sit amet, consectetur adipisicing elit. Quisquam ea repellendus dicta similique quibusdam repellat delectus totam sint voluptate, quidem reiciendis labore, nihil error iusto a, placeat minus hic. Quas!.</p>
                <p>6.9 Создайте массив arrListPlusChildren из элементов массива arrList и их потомков.</p>
                <p>6.10 Создайте массив из 100 элементов массива arrList используя slice().</p>
                <p>6.11 Выведите в консоль все элементы arrList не используя циклов.</p>
                <p>6.12 Создайте массив из nodeName элементов arrList не используя циклов.</p>
                <p>6.13 Создайте массив из withoutSpan c элементов arrList не используя циклов, откинув все span элементы.</p>
                <p>6.14 Напишите функцию createWithoutElemens(arr, str), arr - массив элементов, str - строка с названием эле­мен­тов, которые нужно отсеять в процессе работы функции. Функция возвращает новый массив.</p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->// Example
<!-- example -->function createWithoutElemens(arr, str) {
<!-- example -->    ...
<!-- example -->}
<!-- example -->
<!-- example -->var arrList = [
<!-- example -->    {x : 1, nodeName : 'SPAN'},
<!-- example -->    {x : 2, nodeName : 'DIV'},
<!-- example -->    {x : 3, nodeName : 'SPAN'},
<!-- example -->    {x : 4, nodeName : 'P'},
<!-- example -->    {x : 5, nodeName : 'SPAN'},
<!-- example -->    {x : 6, nodeName : 'DIV'}
<!-- example -->];
<!-- example -->createWithoutElemens(arrList, 'span'); // }-->
<!-- example -->    // {x : 2, nodeName : 'DIV'},
<!-- example -->    // {x : 4, nodeName : 'P'},
<!-- example -->    // {x : 6, nodeName : 'DIV'}
<!-- example -->createWithoutElemens(arrList, 'DIV'); // }-->
<!-- example -->    // {x : 1, nodeName : 'SPAN'},
<!-- example -->    // {x : 3, nodeName : 'SPAN'},
<!-- example -->    // {x : 4, nodeName : 'P'},
<!-- example -->    // {x : 5, nodeName : 'SPAN'}
<!-- example --></code></pre>
                <p>6.15 Напишите аналог функции createWithoutElemens(arr, str), arr - массив элементов, str - строка с названием эле­мен­тов или массив таких строк, которые нужно отсеять в процессе работы функции. Функция возвращает новый массив.</p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->// Example
<!-- example -->function createWithoutElemens(arr, str) {
<!-- example -->    ...
<!-- example -->}
<!-- example -->
<!-- example -->var arrList = [
<!-- example -->    {x : 1, nodeName : 'SPAN'},
<!-- example -->    {x : 2, nodeName : 'DIV'},
<!-- example -->    {x : 3, nodeName : 'SPAN'},
<!-- example -->    {x : 4, nodeName : 'P'},
<!-- example -->    {x : 5, nodeName : 'SPAN'},
<!-- example -->    {x : 6, nodeName : 'DIV'}
<!-- example -->];
<!-- example -->createWithoutElemens(arrList, 'span'); // }-->
<!-- example -->    // {x : 2, nodeName : 'DIV'},
<!-- example -->    // {x : 4, nodeName : 'P'},
<!-- example -->    // {x : 6, nodeName : 'DIV'}
<!-- example -->createWithoutElemens(arrList, ['SPAN', 'DIV']); // }-->
<!-- example -->    // {x : 4, nodeName : 'P'}
<!-- example --></code></pre>
                <p>7. Напишите функцию createRectangle(m, n), Функция возвращает пустой прямоугольный массив m на n. m - количество столбиков, n - количество рядов. n и m генерировать рандомно ( 2 < n 12, 4 < m 6).</p>
                <div class="article-images">
                    <img src="images/lesson_8_2(ex_16).png" alt="">
                </div>
                <p>
                    Напишите функцию createLetter(). Функция возвращает объект - письмо.</br>
                    Письмо:</br>
                    - адресат (destination) - создайте массив people, где каждый элемент объект person и случайным образом получайте это поле.</br>
                    - адресант (addressee) - также из массива people.</br>
                    - время создания (creationTime) - случайное число 0 - new Date().getTime();</br>
                    - тема (subject) - создайте функцию генерирующую тему из случайного количества слов (1 - 4) каждое слово размером 2 - 8 символов.</br>
                    - сообщение (message) - создайте функцию генерирующую message, можно использовать функцию из задания №10 в уроке 6.2.
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->// Example letter
<!-- example -->{
<!-- example -->    destination : {
<!-- example -->        firstName : 'Igor',
<!-- example -->        lastName : 'Igorov',
<!-- example -->        address : 'avenue Pupkina, 14b'
<!-- example -->    },
<!-- example -->    addressee : {
<!-- example -->        firstName : 'Ivan',
<!-- example -->        lastName : 'Ivanov',
<!-- example -->        address : 'Vesuvius vol., 3 palm trees to the right from bar "White coconut"'
<!-- example -->    },
<!-- example -->    creationTime : 900000,
<!-- example -->    subject : 'Lorem ipsum dolor.',
<!-- example -->    message : 'Lorem ipsum dolor sit amet, consectetur adipisicing elit. \
<!-- example -->                Excepturi quidem culpa corporis laudantium, \
<!-- example -->                magnam, eos numquam animi quam.'
<!-- example -->}
<!-- example --></code></pre>
                <p>Положите на случайные позиции массива созданого функциией createRectangle, случайное количество писем из случайным содержимым.</p>
                <p>
                    Подсчитайте количество писем в массиве.
                </p>
                <p>
                    Наклейте на каждое письмо марку с картинкой, картинки найти в google. (Добавляем поле stamp из ссылкой на картинку).
                </p>
            </article>
        </section>
    </main>
    <footer></footer>
</div>
<script src="../js/highlight.pack.js"></script>
<script src="../js/highlightjs-line-numbers.js"></script>
<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>
<script src="../js/main.js"></script>
</body>
</html>

<!--
    <div class="article-images">
        <img src="images/web publishing.png" alt="">
    </div>
-->
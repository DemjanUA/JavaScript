<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Lesson №10 | Функции — часть третья</title>
    <link rel="shortcut icon" href="../images/logo.ico">
    <link rel="stylesheet" href="../css/main.css">
    <!--Fonts-->
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,500,500i,700,700i" rel="stylesheet">

    <link rel="stylesheet" href="../css/atom-one-dark.css">
</head>
<body>
<div class="wrapper">
    <header>
        <a href="/" class="logo">
         <img src="../images/logo.svg" alt="logotype">
        </a>
    </header>
    <main>
        <h1 class="title">Функции — часть третья</h1>
        <h3 class="content-list">Содержание</h3>
        <ul class="plan">
            <li><a href="#s1">Вступление</a></li>
            <li><a href="#s2">Область видимости</a></li>
            <li><a href="#s3">Вложенная область видимости</a></li>
            <li><a href="#s4">Лексическая область видимости</a></li>
            <li><a href="#s5">Лексическое окружение</a></li>
            <li><a href="#s6">Глобальная область видимости</a></li>
            <li><a href="#s7">Замыкания</a></li>
            <li><a href="#s8">Динамическая область видимости</a></li>
            <li><a href="#s9">Паттерн Модуль</a></li>
            <li><a href="#s10">Объект arguments</a></li>
            <li><a href="#s11">Устаревшая конструкция "with"</a></li>
            <li><a href="#s12">Упражнения</a></li>
        </ul>
<!---   SECTION1      -->
        <section class="clearfix" id="s1">
            <article class="main-article fl">
                <h3>1. Вступление</h3>
                <p>
                    Одна из самых фундаментальных парадигм почти всех языков программирования — возможность сохранять значения в переменных, а позже извлекать или менять эти значения. Собственно, возможность хранить значения и извлекать значения из переменных — это то, что дает программе состояние.
                </p>
                <p>
                    Без такого концепта программа могла бы выполнять некоторые задачи, но они были бы весьма ограничены и не были бы очень уж интересны.
                </p>
                <p>
                    Это подталкивает к необходимости в определенном наборе правил описывающих хранение переменных и доступ к ним с других частей программы. Такой набор правил называют — <strong>Областью видимости</strong>.
                </p>
            </article>
        </section>
<!---   SECTION2      -->
        <section class="clearfix" id="s2">
            <article class="main-article fl">
                <h3>2. Область видимости</h3>
                <p>
                     Область видимости — это набор правил, которые определяют где и как переменная (идентификатор) могут быть найдены и доступны с других частей программы. Этот поиск может осуществляться для целей присваивания значения переменной, которая является LHS (left-hand-side) ссылкой, или может осуществляться для целей извлечения ее значения, которое является RHS (right-hand-side) ссылкой.
                </p>
                <p>
                    Есть две преобладающих модели того, как работает область видимости. Первая из них, безусловно самая распространенная, используется необъятным большинством языков программирования. Она называется <strong>Лексическая область видимости</strong> и мы изучим ее в деталях. Другая модель, которая все еще используется некоторыми языками (такими как скриптовый Bash, некоторые режимы в Perl и т.д.), называется <strong>Динамическая область видимости</strong>.
                </p>
                <p>
                    Динамическая область видимости рассматривается и упоминается только чтобы показать контраст с лексической областью действия, которая является моделью области видимости, используемой в JavaScript.
                </p>
            </article>
        </section>
<!---   SECTION3      -->
        <section class="clearfix" id="s3">
            <article class="main-article fl">
                <h3>3. Вложенная область видимости</h3>
                <p>
                    Область видимости — это набор правил поиска переменных по их идентификатору. Однако, обычно бывает более одной области видимости.
                </p>
                <p>
                    Также как блок или функция вкладывается внутрь другого блока или функции, области видимости вкладываются внутрь других областей. Поэтому, если переменную не найти в ближайшей области видимости, движок заглядывает в следующую внешнюю по отношению к этой область видимости, продолжая так до тех пор, пока не найдет или пока не достигнет самой внешней (т.е. глобальной) области.
                    </br>
                    <u>Пример:</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->function foo(a) {
<!-- example -->    console.log( a + b );
<!-- example -->}
<!-- example -->var b = 2;
<!-- example -->foo( 2 ); // 4
<!-- example --></code></pre>
                <p>
                    Простые правила просмотра вложенных областей видимости: движок начинает в текущей выполняемой области видимости, ищет в ней переменную, затем если не находит, продолжает поиск уровнем выше и так далее. Если достигнута самая внешняя глобальная область видимости, поиск останавливается, независимо от того, нашел он переменную или нет.
                </p>
            </article>
        </section>
<!---   SECTION4      -->
        <section class="clearfix" id="s4">
            <article class="main-article fl">
                <h3>4. Лексическая область видимости</h3>
                <p>
                    Лексическая область видимости означает, что область видимости определена решениями о том, где объявляются функции на стадии написания кода. Фаза разбиения на лексемы при компиляции фактически способна узнать где и как объявлены все идентификаторы, и таким образом предсказать как их будут искать во время выполнения.
                    </br>
                    <u>Пример:</u>
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var n = 1;
<!-- example -->function f1(a) {
<!-- example -->    var n = 2;
<!-- example -->    a();
<!-- example -->}
<!-- example -->
<!-- example -->function f2() {
<!-- example -->    console.log(n);
<!-- example -->}
<!-- example -->
<!-- example -->f1(f2); // 1
<!-- example --></code></pre>
            </article>
        </section>
<!---   SECTION5      -->
        <section class="clearfix" id="s5">
            <article class="main-article fl">
                <h3>5. Лексическое окружение</h3>
                <p>
                    Все переменные внутри функции – это свойства специального внутреннего объекта <strong>LexicalEnvironment</strong>, который создаётся при её запуске.
                </p>
                <p>
                    При запуске функция создает объект LexicalEnvironment, записывает туда аргументы, функции и переменные. Процесс инициализации выполняется в том же порядке, что и для глобального объекта, который, вообще говоря, является частным случаем лексического окружения.
                </p>
                <p>
                    В отличие от window, объект LexicalEnvironment является внутренним, он скрыт от прямого доступа.
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var userName = "Alex";
<!-- example -->
<!-- example -->function sayHi() {
<!-- example -->    alert( userName ); // "Вася"
<!-- example -->}
<!-- example --></code></pre>
                <p>
                    Интерпретатор, при доступе к переменной, сначала пытается найти переменную в текущем LexicalEnvironment, а затем, если её нет – ищет во внешнем LexicalEnvironment (в данном случае им является window), который принадлежит внешней области видимости.
                </p>
                <p>
                    Такой порядок поиска возможен благодаря тому, что ссылка на внешний объект переменных хранится в специальном внутреннем свойстве функции, которое называется [[Scope]]. Это свойство закрыто от прямого доступа, но знание о нём очень важно для понимания того, как работает JavaScript.
                </p>
                <p>
                    При создании функция получает скрытое свойство [[Scope]], которое <strong>ссылается на лексическое окружение области видимости</strong> (не на всю ОВ, а только на LexicalEnvironment ОВ), в которой она была создана.
                </p>
                <p>
                    Это свойство никогда не меняется. Оно всюду следует за функцией, привязывая её, таким образом, к месту своего рождения.
                </p>
                <p>
                    <strong>При запуске</strong> функции её объект переменных LexicalEnvironment получает ссылку на «внешнее лексическое окружение» со значением из [[Scope]].
                </p>
                <p>
                    <strong>Значение переменной из внешней области берётся всегда текущее. Оно может быть уже не то, что было на момент создания функции.</strong>
                </p>
                <p>
                    Это естественно, ведь для доступа к внешней переменной функция по ссылке [[Scope]] обращается во внешний объект переменных и берёт то значение, которое там есть на момент обращения.
                </p>
            </article>
        </section>
<!---   SECTION6      -->
        <section class="clearfix" id="s6">
            <article class="main-article fl">
                <h3>6. Глобальная область видимости</h3>
                <p>
                    Глобальная область видимости является лексической ОВ, она всегда будет на вершине иерархии любой вложенности областей видимости.
                </p>
                <p>
                    Также глобальная область видимости хранит LexicalEnvironment который является конечным звеном в цепочке лексических окружений.
                </p>
            </article>
        </section>
<!---   SECTION7      -->
        <section class="clearfix" id="s7">
            <article class="main-article fl">
                <h3>7. Замыкания</h3>
                <p>
                </p>

                <p>
                    Технически все функции в языке JavaScript образуют замыкания: они являются объектами и имеют ассоциированные с ними цепочки областей видимости. Большинство функций вызываются внутри той же цепочки областей видимости, которая действовала на момент определения функции, и в этой ситуации факт образования замыкания не имеет никакого значения. Интересные особенности замыканий начинают проявляться, когда их вызов производится в другой цепочке областей видимости, отличной от той, что действовала на момент определения. Чаще всего это происходит, когда объект вложенной функции возвращается функцией, вмещающей ее определение. Существует множество мощных приемов программирования, вовлекающих такого рода вложенные функции-замыкания, и их использование довольно широко распространено в программировании на языке JavaScript. Замыкания могут выглядеть малопонятными при первом знакомстве, однако вам необходимо хорошо понимать их, чтобы чувствовать себя уверенно при их использовании. 
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var scope = "global scope"; // Гло­баль­ная пе­ре­мен­ная
<!-- example -->function checkscope() {
<!-- example -->    var scope = "local scope"; // Ло­каль­ная пе­ре­мен­ная
<!-- example -->    function f() { return scope; } // Вер­нет зна­че­ние ло­каль­ной пе­ре­мен­ной scope
<!-- example -->        return f;
<!-- example -->    }   
<!-- example -->checkscope()();
<!-- example --></code></pre>
                </br>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var a = 1;
<!-- example -->var foo = (function f1() {
<!-- example -->    var b = 2;
<!-- example -->    return (function f2() {
<!-- example -->        var c = 3;
<!-- example -->        return (function f3() {
<!-- example -->            var d = 4;
<!-- example -->            return function() {
<!-- example -->                console.log(a, b, c, d);
<!-- example -->            }
<!-- example -->        })();
<!-- example -->    })();
<!-- example -->})();
<!-- example -->foo();
<!-- example --></code></pre>
                </br>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var uniqueInteger = (function() {
<!-- example -->    var counter = 0; // Ча­ст­ное (private) зна­че­ние для функ­ции ни­же
<!-- example -->        return function() {
<!-- example -->            return counter++;
<!-- example -->        };
<!-- example -->}());
<!-- example --></code></pre>
            <p>
                Внимательно изучите этот пример, чтобы понять, как он действует. На первый взгляд, первая строка выглядит как инструкция присваивания функции переменной uniqueInteger. Фактически же это определение и вызов функции (как подсказывает открывающая круглая скобка в первой строке), поэтому в действительности переменной uniqueInteger присваивается значение, возвращаемое функцией. Если теперь обратить внимание на тело функции, можно увидеть, что она возвращает другую функцию. Именно этот объект вложенной функции и присваивается переменной uniqueInteger. Вложенная функция имеет доступ к переменным в ее области видимости и может использовать переменную counter, объявленную во внешней функции. После возврата из внешней функции никакой другой программный код не будет иметь доступа к переменной counter: вложенная функция будет обладать исключительным правом доступа к ней.
            </p>
            <p>
                Скрытые переменные, такие как counter, не являются исключительной собственностью единственного замыкания: в одной и той же внешней функции вполне возможно определить две или более вложенных функций, которые будут совместно использовать одну цепочку областей видимости. Рассмотрим следующий пример:
            </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->function counter() {
<!-- example -->    var n = 0;
<!-- example -->    return {
<!-- example -->        count: function() {
<!-- example -->            return ++n;
<!-- example -->        },
<!-- example -->        reset: function() {
<!-- example -->            n = 0;
<!-- example -->        }
<!-- example -->    };
<!-- example -->}
<!-- example -->var c = counter(), d = counter(); // Соз­дать два счет­чи­ка
<!-- example -->
<!-- example -->c.count() // => 1
<!-- example -->d.count() // => 1 // они дей­ст­ву­ют не­за­ви­си­мо
<!-- example -->c.reset()
<!-- example -->c.count()
<!-- example -->d.count()
<!-- example --></code></pre>
                <p>
                    Функция counter() возвращает объект «счетчика». Этот объект имеет два метода: count(), возвращающий следующее целое число, и reset(), сбрасывающий счетчик в начальное состояние. В первую очередь следует запомнить, что два метода совместно используют одну и ту же частную переменную n. Во-вторых, каждый вызов функции counter() создает новую цепочку областей видимости и новую скрытую переменную. То есть, если вызвать функцию counter() дважды, она вернет два объекта-счетчика с различными скрытыми переменными. Вызов методов count() и reset() одного объекта-счетчика не оказывает влияния на другой.
                </p>
                <p class="blockquote">
                    Почтенный мастер Ку Чи шел со своим учеником, Антоном. Надеясь вступить с мастером в дискуссию, Антон сказал: «Учитель, я слышал, что объекты это очень хорошая вещь — это правда?» Ку Чи с сожалением посмотрел на своего ученика и ответил: «Мой глупый ученик, объекты — это замыкания для бедных.» Антон поклонился и вернулся в свою келью изучать замыкания. Он внимательно прочитал всю серию работ «Lambda: The Ultimate…», потом все остальные статьи по этой теме, и создал небольшой интерпретатор с использованием объектов эмулирующих функционал замыканий. Он многому научился, и стал искать встречи с мастером, чтобы похвастаться. На своей следующей прогулке с Ку Чи, Антон сказал: «Учитель, я усердно изучал этот вопрос, и теперь понимаю, что объекты действительно являются замыканиями для бедных.» Ку Чи ударил Антона своей палкой и сказал: «Когда же ты научишься? Замыкания — это объекты для бедных». В этот самый момент Антон достиг просветления.
                </p>
                <p>
                    Как и объекты, замыкания предлагают механизм сохранения состояния. В JavaScript замыкание создается всякий раз, когда функция получает доступ к переменной, определенной вне непосредственной области видимости функции.
                </p>
                <p>
                    Похоже, что знания о замыкании полны предрассудков и суеверий как загадочный мир, стоящий особняком внутри JavaScript, который могут познать только самые храбрые души. Но на самом деле — это всего лишь стандартный и почти очевидный факт о том, как писать код в среде лексической области видимости, где функции являются значениями и могут свободно передаваться куда угодно.
                </p>
                <p>
                    Замыкание — это когда функция может запомнить и иметь доступ к своей лексической области видимости даже тогда, когда она вызывается вне своей лексической области видимости.
                </p>
            </article>
        </section>
<!---   SECTION8      -->
        <section class="clearfix" id="s8">
            <article class="main-article fl">
                <h3>8. Динамическая область видимости</h3>
                <p>
                    Мы кратко рассмотрим динамическую область видимости, чтобы крепко усвоить разницу.
                </p>
                <p>
                    Динамическая область видимости означает что есть модель, при помощи которой область видимости можно определить динамически во время выполнения, вместо статического определения при написании кода. То, что нам нужно. Давайте отразим это в коде:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->function foo() {
<!-- example -->    console.log( a ); // 2
<!-- example -->}
<!-- example -->
<!-- example -->function bar() {
<!-- example -->    var a = 3;
<!-- example -->    foo();
<!-- example -->}
<!-- example -->
<!-- example -->var a = 2;
<!-- example -->
<!-- example -->bar();
<!-- example --></code></pre>
                <p>
                    Лексическая область видимости хранит информацию о том, где была создана foo(), что приведет к тому, что будет выведено значение 2.
                </p>
                <p>
                    Динамическая область видимости, не интересуется тем как и где были объявлены функции и области видимости, а скорее интересуется тем откуда они буду вызываться. Здесь цепочка областей видимости основана на стеке вызовов, а не на вложенности областей видимости в коде.
                </p>
                <p>
                    Итак, если бы в JavaScript была динамическая область видимости, то когда выполнилась бы foo(), теоретически вышеприведенный код привел бы к выводу 3.
                </p>
                <p>
                    Чтобы внести ясность, в JavaScript нет, на самом деле, динамической области видимости. В нем есть лексическая область видимости. Проще некуда. Но механизм работы this немного похож на динамическую область видимости.
                </p>
                <p>
                    Ключевое сравнение: лексическая область видимости определяется временем написания кода, тогда как динамическая область видимости (и this!) определяется во время выполнения. Лексическую область видимости интересует где функция была объявлена, а динамическую — откуда была вызвана функция.
                </p>
                <p>
                    И наконец: this интересует как была вызвана функция, что показывает как близко связаны механизм this с идеей динамической области видимости.
                </p>
            </article>
        </section>
<!---   SECTION9      -->
        <section class="clearfix" id="s9">
            <article class="main-article fl">
                <h3>9. Паттерн Модуль</h3>
                <p>
                    Есть еще паттерны программирования, которые эффективно используют мощь замыканий, но которые внешне не особенно похожи на функции обратного вызова. Давайте рассмотрим самый мощный из них: <strong>модуль</strong>.
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->function foo() {
<!-- example -->    var something = "cool";
<!-- example -->    var another = [1, 2, 3];
<!-- example -->
<!-- example -->    function doSomething() {
<!-- example -->        console.log( something );
<!-- example -->    }
<!-- example -->
<!-- example -->    function doAnother() {
<!-- example -->        console.log( another.join( " ! " ) );
<!-- example -->    }
<!-- example -->}
<!-- example --></code></pre>
                <p>
                    Как видно из этого кода, здесь нет никакого явного замыкания. У нас просто есть некоторые приватные переменные something и another, а также парочка внутренних функций doSomething() и doAnother(), у обеих из которых есть лексическая область видимости (а потому и замыкание!) над внутренней областью foo().
                </p>
                <p>
                    А теперь смотрите:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->function CoolModule() {
<!-- example -->    var something = "cool";
<!-- example -->    var another = [1, 2, 3];
<!-- example -->
<!-- example -->    function doSomething() {
<!-- example -->        console.log( something );
<!-- example -->    }
<!-- example -->
<!-- example -->    function doAnother() {
<!-- example -->        console.log( another.join( " ! " ) );
<!-- example -->    }
<!-- example -->
<!-- example -->    return {
<!-- example -->        doSomething: doSomething,
<!-- example -->        doAnother: doAnother
<!-- example -->    };
<!-- example -->}
<!-- example -->
<!-- example -->var foo = CoolModule();
<!-- example -->
<!-- example -->foo.doSomething(); // cool
<!-- example -->foo.doAnother(); // 1 ! 2 ! 3
<!-- example --></code></pre>
                <p>
                    Этот шаблон в JavaScript мы называем модуль. Самый распространенный путь реализации шаблона модуля часто называют "Действенный модуль" и это тот вариант, который мы тут и представили.
                </p>
                <p>
                    Вышеприведенный код показывает автономный конструктор модуля с названием CoolModule(), который можно вызвать любое количество раз, каждый раз создавая новый экземпляр модуля. Небольшая вариация этого шаблона — это когда вы заботитесь о том, чтобы был только один экземпляр, что-то вроде "синглтона":
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var foo = (function CoolModule() {
<!-- example -->    var something = "cool";
<!-- example -->    var another = [1, 2, 3];
<!-- example -->
<!-- example -->    function doSomething() {
<!-- example -->        console.log( something );
<!-- example -->    }
<!-- example -->
<!-- example -->    function doAnother() {
<!-- example -->        console.log( another.join( " ! " ) );
<!-- example -->    }
<!-- example -->
<!-- example -->    return {
<!-- example -->        doSomething: doSomething,
<!-- example -->        doAnother: doAnother
<!-- example -->    };
<!-- example -->})();
<!-- example -->
<!-- example -->foo.doSomething(); // cool
<!-- example -->foo.doAnother(); // 1 ! 2 ! 3
<!-- example --></code></pre>
                <p>
                    Модули — это всего лишь функции, поэтому они могут принимать параметры:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->function CoolModule(id) {
<!-- example -->    function identify() {
<!-- example -->        console.log( id );
<!-- example -->    }
<!-- example -->
<!-- example -->    return {
<!-- example -->        identify: identify
<!-- example -->    };
<!-- example -->}
<!-- example -->
<!-- example -->var foo1 = CoolModule( "foo 1" );
<!-- example -->var foo2 = CoolModule( "foo 2" );
<!-- example -->
<!-- example -->foo1.identify(); // "foo 1"
<!-- example -->foo2.identify(); // "foo 2"
<!-- example --></code></pre>
                <p>
                    Еще одна небольшая, но полнофункциональная вариация модульного шаблона — дать имя объекту, который вы возвращаете как публичное API:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var foo = (function CoolModule(id) {
<!-- example -->    function change() {
<!-- example -->        // modifying the public API
<!-- example -->        publicAPI.identify = identify2;
<!-- example -->    }
<!-- example -->
<!-- example -->    function identify1() {
<!-- example -->        console.log( id );
<!-- example -->    }
<!-- example -->
<!-- example -->    function identify2() {
<!-- example -->        console.log( id.toUpperCase() );
<!-- example -->    }
<!-- example -->
<!-- example -->    var publicAPI = {
<!-- example -->        change: change,
<!-- example -->        identify: identify1
<!-- example -->    };
<!-- example -->
<!-- example -->    return publicAPI;
<!-- example -->})( "foo module" );
<!-- example -->
<!-- example -->foo.identify(); // foo module
<!-- example -->foo.change();
<!-- example -->foo.identify(); // FOO MODULE
<!-- example --></code></pre>
                <p>
                    Сохраняя внутреннюю ссылку на объект публичного API внутри экземпляра модуля вы можете менять эту ссылку на модуль изнутри, включая добавление и удаление методов, свойств и изменение их значений.
                </p>
                <p>
                    Модули требуют две ключевых характеристики: 1) внешнюю функцию-обертку, которую будут вызывать, чтобы создать закрытую область видимости 2) возвращаемое значение функции-обертки должно включать в себя ссылку на не менее чем одну внутреннюю функцию, у которой потом будет замыкание на внутреннюю область видимости обертки.
                </p>
                <p>
                    Теперь вы сможете заметить замыкания повсюду в своем существующем коде и у нас теперь есть возможность обнаруживать и использовать все их преимущества!
                </p>
            </article>
        </section>
<!---   SECTION10      -->
        <section class="clearfix" id="s10">
            <article class="main-article fl">
                <h3>10. Объект arguments</h3>
                <p>
                    Если число аргументов в вызове функции превышает число имен параметров, функция лишается возможности напрямую обращаться к неименованным значениям. Решение этой проблемы предоставляет объект Arguments. В теле функции идентификатор arguments ссылается на объект Arguments, присутствующий в вызове. Объект Arguments – это объект, подобный массиву, позволяющий извлекать переданные функции значения по их номерам, а не по именам.
                </p>
                <p>
                    Предположим, что была определена функция f, которая требует один аргумент, x. Если вызвать эту функцию с двумя аргументами, то первый будет доступен внутри функции по имени параметра x или как arguments[0]. Второй аргумент будет доступен только как arguments[1]. Кроме того, подобно настоящим массивам, arguments имеет свойство length, определяющее количество содержащихся элементов. То есть в теле функции f, вызываемой с двумя аргументами, arguments.length имеет значение 2. 
                </p>
                <p>
                    Объект Arguments иллюстрирует важную возможность JavaScript-функций: они могут быть написаны таким образом, чтобы работать с любым количеством аргументов. Следующая функция принимает любое число аргументов и возвращает значение самого большого из них (аналогично ведет себя встроенная функция Math.max()).
                </p>
                <p>
                    Функции, подобные этой и способные принимать произвольное число аргументов, называются функциями с переменным числом аргументов (variadic functions, variable arity functions или varargs functions). Этот термин возник вместе с появлением языка программирования C.
                </p>
                <p>
                    Не следует забывать, что arguments фактически не является массивом – это объект Arguments. В каждом объекте Arguments имеются пронумерованные элементы массива и свойство length, но с технической точки зрения это не массив. Лучше рассматривать его как объект, имеющий некоторые пронумерованные свойства. 
                </p>
            </article>
        </section>
<!---   SECTION11      -->
        <section class="clearfix" id="s11">
            <article class="main-article fl">
                <h3>11. Устаревшая конструкция "with"</h3>
                <p>
                    Конструкция with позволяет использовать в качестве области видимости для переменных произвольный объект.
                </p>
                <p>
                    В современном JavaScript от этой конструкции отказались. С use strict она не работает, но её ещё можно найти в старом коде, так что стоит познакомиться с ней, чтобы если что – понимать, о чём речь.
                    </br>
                    </br>
                    Синтаксис:
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->with(obj) {
<!-- example -->  ...код...
<!-- example -->}
<!-- example --></code></pre>
                <p>
                    Любое обращение к переменной внутри with сначала ищет её среди свойств obj, а только потом – вне with.
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var a = 5;
<!-- example -->
<!-- example -->var obj = {
<!-- example -->    a: 10
<!-- example -->};
<!-- example -->
<!-- example -->with(obj) {
<!-- example -->    alert( a ); // 10, из obj
<!-- example -->}
<!-- example --></code></pre>
            </article>
        </section>
<!---   SECTION12      -->
        <section class="clearfix" id="s12">
            <article class="main-article fl">
                <h3>12. Упражнения</h3>
                <h4>1. Векторный тип</h4>
                <p>
                    Напишите конструктор Vector, представляющий вектор в двумерном пространстве. Он принимает параметры x и y (числа), которые хранятся в одноимённых свойствах.
                </p>
                <p>
                    Дайте Vector два метода, plus и minus, которые принимают другой вектор в качестве параметра и возвращают новый вектор, который хранит в x и y сумму или разность двух векторов (один this, второй – аргумент).
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->console.log(new Vector(1, 2).plus(new Vector(2, 3)));
<!-- example -->// → Vector{x: 3, y: 5}
<!-- example -->console.log(new Vector(1, 2).minus(new Vector(2, 3)));
<!-- example -->// → Vector{x: -1, y: -1}
<!-- example -->console.log(new Vector(3, 4).length); // Длина вектора
<!-- example --></code></pre>
                <p>
                    После, реализуйте модуль Vector. Вынесите интерфейс.
                </p>
                <h4>2. Названия месяцев</h4>
                <p>
                    Напишите простой модуль month, преобразующий номера месяцев (начиная с нуля) в названия и обратно. Выделите ему собственное пространство имён, т.к. ему потребуется внутренний массив с названиями месяцев.
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->console.log(month.name(2));
<!-- example -->// → March
<!-- example -->console.log(month.number("November"));
<!-- example -->// → 10
<!-- example --></code></pre>
                <h4>3. Counter</h4>
                <p>
                    Реализуйте конструктор счет­чи­ка Counter(id), id уникальный идентификатор счетчика.
                    Counter.prototype.count - поле счет­чи­ка.
                    Counter.prototype.reset() - обнуляет счетчик.
                    set Counter.prototype.count(value) - позволяет установить счетчик.
                    get Counter.prototype.id - возвращает идентификатор счетчика.
                    Counter.prototype.autoCounting(timeout) - позволяет установить автоматическое увеличение счетчика через timeout.
                    Counter.prototype.startCounting(timeout) - запускает автоматическое увеличение счетчика.
                    Counter.prototype.stopCounting(timeout) - отменяет автоматическое увеличение счетчика.
                </p>
                <p>
                    После, реализуйте модуль Counter. Вынесите интерфейс.
                </p>
                <h4>4. allArguments</h4>
                <p>
                    Напишите функцию allArguments, что выводит в консоль все аргементы переданые функции ( количество аргументов зарание неизвесно).
                </p>
                <h4>5. allArgumentsAdd</h4>
                <p>
                    Напишите функцию allArgumentsAdd, что возвращает суму всех аргументов переданных функции (количество аргументов зарание неизвесно).
                </p>
                <h4>6. Car</h4>
                <p>
                    Создайте конструктор Car, детально описывающиющий свойство автомобиля (минимум 15 полей).
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var chevy = new Car("Chevy", "Bel Air", 1957, "red", 2, false, 1021);
<!-- example -->var cadi = new Car("GM", "Cadillac", 1955, "tan", 5, false, 12892);
<!-- example -->var taxi = new Car("Webville Motors", "Taxi", 1955, "yellow", 4, false, 281341);
<!-- example -->var fiat = new Car("Fiat", "500", 1957, "Medium Blue", 2, false, 88000);
<!-- example --></code></pre>
                </p>
                <p>
                    Создайте массив марок автомобилей и на основе создайте массив из экземпляров Car(brand) (минимум 10 елементов).
                </p>
                <h4>6. Cars brand</h4>
                <p>
                    Создайте функцию, получает в качестве аргументов марки автомобилей и выводит их в консоль в одну строку через запятую и пробел.
                </p>
            </article>
        </section>
    </main>
    <footer></footer>
</div>
<script src="../js/highlight.pack.js"></script>
<script src="../js/highlightjs-line-numbers.js"></script>
<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>
<script src="../js/main.js"></script>
</body>
</html>

<!--
    <div class="article-images">
        <img src="images/web publishing.png" alt="">
    </div>
-->
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Unit №1 | Объектная модель документа (DOM)</title>
    <link rel="shortcut icon" href="../images/logo.ico">
    <link rel="stylesheet" href="../css/main.css">
    <!--Fonts-->
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,500,500i,700,700i" rel="stylesheet">

    <link rel="stylesheet" href="../css/atom-one-dark.css">
</head>
<body>
<div class="wrapper">
    <header>
        <a class="go-home-page clearfix" href="../index.html">
            <svg class="fl" xmlns="http://www.w3.org/2000/svg" width="32px" height="32px" viewBox="0 0 24 24">
                <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path>
            </svg>
            <span class="fl">Home</span>
        </a>
        <a href="/" class="logo">
         <img src="../images/logo.svg" alt="logotype">
        </a>
    </header>
    <main>
        <h1 class="title">Объектная модель документа (DOM)</h1>
        <h3 class="content-list">Содержание</h3>
        <ul class="plan">
            <li><a href="#s1">Вступление</a></li>
            <li><a href="#s2">Графы, дерево DOM</a></li>
            <li><a href="#s3">Узлы</a></li>
            <li><a href="#s4">Свойства узлов: тип, тег и содержимое</a></li>
        </ul>
<!---   SECTION1      -->
        <section class="clearfix" id="s1">
            <article class="main-article fl">
                <h3>1. Вступление</h3>
                <p>
                    Объектная Модель Документа (DOM) – это программный интерфейс (API) для HTML и XML документов. DOM предоставляет структурированное представление документа и определяет то, как эта структура может быть доступна из программ, которые могут изменять содержимое, стиль и структуру документа. Представление DOM состоит из структурированной группы узлов и объектов, которые имееют свойства и методы. По существу DOM соединяет веб-страницу с языками описания сценариев либо языками программирования.
                </p>
                <p>
                    Веб-страница – это документ. Документ может быть представлен как в окне браузера, так и в самом HTML-коде. В любом случае, это один и тот же документ. DOM предоставляет другой способ представления, хранения и управления этого документа. DOM полностью поддерживает <strong>объектно-ориентированнное</strong> представление веб-страницы, делая возможным её изменение при помощи языка описания сценариев наподобие JavaScript.
                </p>
                <div class="article-images small-img-7">
                    <img src="images/lesson_13(dom_part_of_window).png" alt="">
                </div>
                <p>
                    Стандарты W3C DOM и WHATWG DOM формируют основы DOM, реализованные в большинстве современных браузеров. Многие браузеры предлагают расширения за пределами данного стандарта, поэтому необходимо проверять работоспособность тех или иных возможностей DOM для каждого конкретного браузера.
                </p>
                <p>
                    DOM не является языком программирования, но без него, JavaScript он не имел бы никакой модели или представления о веб-странице, HTML-документе, XML-документе и их элементах. Каждый элемент в документе - весь документ в целом, заголовок, таблицы внутри документа, заголовки таблицы, текст внутри ячеек таблицы - это части объектной документной модели для этого документа, поэтому все они могут быть доступны и могут изменяться с помощью DOM и скриптового языка наподобие JavaScript.
                </p>
                <p>
                    В начале, JavaScript и DOM были тесно связанны, но в последствии они развились в различные сущности. Содержимое страницы хранится в DOM и может быть доступно и изменяться с использованием JavaScript, поэтому мы можем записать это в виде приблизительного равенства:
                </p>
                <p>
                    DOM предполагался быть независимым от любого конкретного языка программирования, обеспечивая структурное представление документа согласно единому и последовательному API. Хотя и все сфокусировано на JavaScript, реализация DOM может быть построена для любого языка.
                </p>
            </article>
        </section>
<!---   SECTION2      -->
        <section class="clearfix" id="s2">
            <article class="main-article fl">
                <h3>2. Графы, дерево DOM</h3>
                <p>
                    Граф — абстрактный математичекий объект, представлющий из себя множество вершин графа и набор рёбер, то есть соединени между парами вершин.
                </p>
                <p>
                    Теория графов — раздел дискретной математики, изучающий свойства графов.
                </p>
                <p>
                    При изображении графов на рисунках чаще всего используется следующая система обозначений: вершины графа изображаются точками или, при конкретизации смысла вершины, прямоугольниками, овалами и др., где внутри фигуры раскрывается смысл вершины (графы блок-схем алгоритмов). Если между вершинами существует ребро, то соответствующие точки (фигуры) соединяются линией или дугой.
                </p>
                <div class="article-images small-img-7">
                    <img src="images/lesson_13(graph_img).jpg" alt="">
                </div>
                <p>
                    Дерево — это связный ациклический граф. Связность означает наличие путей между любой парой вершин, ацикличность — отсутствие циклов и то, что между парами вершин имеется только по одному пути.
                </p>
                <div class="article-images small-img-7">
                    <img src="images/lesson_13(graph_tree).png" alt="">
                </div>
                <p>
                    DOM - это древовидная структура, где вершины представлены объектами класса Node (узел). Для реализации алгоритмов работы с DOM используют свойства графов.
                </p>
                <div class="article-images small-img-7">
                    <img src="images/lesson_13(dom_graph_tree).png" alt="">
                </div>
            </article>
        </section>
<!---   SECTION3      -->
        <section class="clearfix" id="s3">
            <article class="main-article fl">
                <h3>3. Узлы</h3>
                <p>
                    Самое главное различие между DOM-узлами – разные узлы являются объектами различных классов.
                </p>
                <p>
                    Поэтому, к примеру, у узла, соответствующего тегу &#60;td&#62; – одни свойства, у &#60;form&#62; – другие, у &#60;a&#62; – третьи.
                </p>
                <p>
                    Есть и кое-что общее, за счёт наследования.
                </p>
                <p>
                    На рисунке выше изображены <strong>основные</strong> классы:
                </p>
                <div class="article-images small-img-7">
                    <img src="images/lesson_13(real_dom_prototype_tree).png" alt="">
                </div>
                <p>
                    Узнать класс узла очень просто – достаточно привести его к строке, к примеру, вывести:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->alert( document.body ); // [object HTMLBodyElement]
<!-- example --></code></pre>
                <p>
                    Как видно, DOM-узлы – обычные JavaScript-объекты. Их классы заданы в прототипном стиле. В этом легко убедиться, если вывести в консоли любой элемент через console.dir(elem). Или даже можно напрямую обратиться к методам, которые хранятся в Node.prototype, Element.prototype и так далее.
                </p>
                <p>
                    Далее в этом мы поговорим о самых главных свойствах узлов DOM, которые используются наиболее часто.
                </p>
            </article>
        </section>
<!---   SECTION4      -->
        <section class="clearfix" id="s4">
            <article class="main-article fl">
                <h3>4. Свойства узлов: тип, тег и содержимое</h3>
                <h4>4.1 Свойство nodeType</h4>
                <p>
                    Тип узла содержится в его свойстве nodeType.
                </p>
                <ul class="item-list wide">
                    <li>
                        ELEMENT_NODE = 1;
                    </li>
                    <li>
                        ATTRIBUTE_NODE = 2;
                    </li>
                    <li>
                        TEXT_NODE = 3;
                    </li>
                    <li>
                        CDATA_SECTION_NODE = 4;
                    </li>
                    <li>
                        ENTITY_REFERENCE_NODE = 5;
                    </li>
                    <li>
                        ENTITY_NODE = 6;
                    </li>
                    <li>
                        PROCESSING_INSTRUCTION_NODE = 7;
                    </li>
                    <li>
                        COMMENT_NODE = 8;
                    </li>
                    <li>
                        DOCUMENT_NODE = 9;
                    </li>
                    <li>
                        DOCUMENT_TYPE_NODE = 10;
                    </li>
                    <li>
                        DOCUMENT_FRAGMENT_NODE = 11;
                    </li>
                    <li>
                        NOTATION_NODE = 12;
                    </li>
                </ul>
                <p>
                    В частности, тип «Элемент» ELEMENT_NODE имеет номер 1, а «Текст» TEXT_NODE – номер 3.
                </p>
                <p class="warning">
                    Тип узла можно только читать, изменить его невозможно.
                </p>
                <h4>4.2 Свойства nodeName и tagName</h4>
                <p>
                    Существует целых два свойства: nodeName и tagName, которые содержат название(тег) элемента узла.
                </p>
                <p class="warning">
                    Название HTML-тега всегда находится в верхнем регистре.
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->alert( document.body.nodeName ); // BODY
<!-- example -->alert( document.body.tagName ); // BODY
<!-- example --></code></pre>
                <p>
                    Разница отражена в названиях свойств, но неочевидна:
                </p>
                 <ul class="item-list extrawide">
                    <li>- Свойство tagName есть только у элементов Element</li>
                    <li>- Свойство nodeName определено для любых узлов Node, для элементов оно равно tagName, а для не-элементов обычно содержит строку с типом узла.</li>
                </ul>
                <p>
                    При работе с элементами, как это обычно бывает, имеет смысл использовать свойство tagName – оно короче.
                </p>
                <h4>4.3 Свойство innerHTML</h4>
                    <p>
                        Свойство innerHTML позволяет получить HTML-содержимое элемента в виде строки. В innerHTML можно и читать и писать.
                    </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->alert( document.body.innerHTML );
<!-- example -->alert( document.body.innerHTML = 'Hello World' );
<!-- example --></code></pre>
                <p class="info">
                    Значение, возвращаемое innerHTML – всегда валидный HTML-код. При записи можно попробовать записать что угодно, но браузер исправит ошибки:
                </p>
                <p><strong>Свойство innerHTML – одно из самых часто используемых.</strong></p>
                <p>
                    Свойство outerHTML содержит HTML элемента целиком.
                </p>
                <h4>Свойства nodeValue и data</h4>
                <p>
                    Свойство innerHTML есть только у узлов-элементов.
                </p>
                <p>
                    Содержимое других узлов, например, текстовых или комментариев, доступно на чтение и запись через свойство data.
                </p>
                <p class="warning">
                    Свойство nodeValue мы использовать не будем.</br>
                    Оно работает так же, как data, но на некоторых узлах, где data нет, nodeValue есть и имеет значение null. Как-то использовать это тонкое отличие обычно нет причин.
                </p>
                <h4>4.5 Свойство textContent</h4>
                <p>
                    Свойство textContent содержит только текст внутри элемента, за вычетом всех тегов.
                </p>
<!-- example --><pre><code class="html">&#60;div&#62;
<!-- example -->  &#60;h1>Срочно в номер!&#60;/h1&#62;
<!-- example -->  &#60;p>Марсиане атакуют людей!&#60;/p&#62;
<!-- example -->&#60;/div&#62;
<!-- example --><code></pre>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var news = document.body.children[0];
<!-- example -->
<!-- example -->// \n  Срочно в номер!\n  Марсиане атакуют людей!\n
<!-- example -->alert( news.textContent )
<!-- example --></code></pre>
                <p>
                    Как видно из примера выше, возвращается в точности весь текст, включая переводы строк и пробелы, но без тегов.
                </p>
                <p>
                    Иными словами, elem.textContent возвращает конкатенацию всех текстовых узлов внутри elem.
                </p>
                <h4>4.6 Свойство hidden</h4>
                <p>
                    Как правило, видим или невидим узел, определяется через CSS, свойствами display или visibility.
                </p>
                <p>
                    В стандарте HTML5 предусмотрен специальный атрибут и свойство для этого: hidden.
                </p>
                <p>
                    Технически, атрибут hidden работает так же, как style="display:none". Но его проще поставить через JavaScript (меньше букв), и могут быть преимущества для скринридеров и прочих нестандартных браузеров.
                </p>
            </article>
        </section>
<!---   SECTION5      -->
        <section class="clearfix" id="s5">
            <article class="main-article fl">
                <h3>5. Лексическое окружение</h3>
                <p>
                    Все переменные внутри функции – это свойства специального внутреннего объекта <strong>LexicalEnvironment</strong>, который создаётся при её запуске.
                </p>
                <p>
                    При запуске функция создает объект LexicalEnvironment, записывает туда аргументы, функции и переменные. Процесс инициализации выполняется в том же порядке, что и для глобального объекта, который, вообще говоря, является частным случаем лексического окружения.
                </p>
                <p>
                    В отличие от window, объект LexicalEnvironment является внутренним, он скрыт от прямого доступа.
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var userName = "Alex";
<!-- example -->
<!-- example -->function sayHi() {
<!-- example -->    alert( userName ); // "Вася"
<!-- example -->}
<!-- example --></code></pre>
                <p>
                    Интерпретатор, при доступе к переменной, сначала пытается найти переменную в текущем LexicalEnvironment, а затем, если её нет – ищет во внешнем LexicalEnvironment (в данном случае им является window), который принадлежит внешней области видимости.
                </p>
                <p>
                    Такой порядок поиска возможен благодаря тому, что ссылка на внешний объект переменных хранится в специальном внутреннем свойстве функции, которое называется [[Scope]]. Это свойство закрыто от прямого доступа, но знание о нём очень важно для понимания того, как работает JavaScript.
                </p>
                <p>
                    При создании функция получает скрытое свойство [[Scope]], которое <strong>ссылается на лексическое окружение области видимости</strong> (не на всю ОВ, а только на LexicalEnvironment ОВ), в которой она была создана.
                </p>
                <p>
                    Это свойство никогда не меняется. Оно всюду следует за функцией, привязывая её, таким образом, к месту своего рождения.
                </p>
                <p>
                    <strong>При запуске</strong> функции её объект переменных LexicalEnvironment получает ссылку на «внешнее лексическое окружение» со значением из [[Scope]].
                </p>
                <p>
                    <strong>Значение переменной из внешней области берётся всегда текущее. Оно может быть уже не то, что было на момент создания функции.</strong>
                </p>
                <p>
                    Это естественно, ведь для доступа к внешней переменной функция по ссылке [[Scope]] обращается во внешний объект переменных и берёт то значение, которое там есть на момент обращения.
                </p>
            </article>
        </section>
<!---   SECTION6      -->
        <section class="clearfix" id="s6">
            <article class="main-article fl">
                <h3>6. Глобальная область видимости</h3>
                <p>
                    Глобальная область видимости является лексической ОВ, она всегда будет на вершине иерархии любой вложенности областей видимости.
                </p>
                <p>
                    Также глобальная область видимости хранит LexicalEnvironment который является конечным звеном в цепочке лексических окружений.
                </p>
            </article>
        </section>
<!---   SECTION7      -->
        <section class="clearfix" id="s7">
            <article class="main-article fl">
                <h3>7. Замыкания</h3>
                <p>
                </p>

                <p>
                    Технически все функции в языке JavaScript образуют замыкания: они являются объектами и имеют ассоциированные с ними цепочки областей видимости. Большинство функций вызываются внутри той же цепочки областей видимости, которая действовала на момент определения функции, и в этой ситуации факт образования замыкания не имеет никакого значения. Интересные особенности замыканий начинают проявляться, когда их вызов производится в другой цепочке областей видимости, отличной от той, что действовала на момент определения. Чаще всего это происходит, когда объект вложенной функции возвращается функцией, вмещающей ее определение. Существует множество мощных приемов программирования, вовлекающих такого рода вложенные функции-замыкания, и их использование довольно широко распространено в программировании на языке JavaScript. Замыкания могут выглядеть малопонятными при первом знакомстве, однако вам необходимо хорошо понимать их, чтобы чувствовать себя уверенно при их использовании. 
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var scope = "global scope"; // Гло­баль­ная пе­ре­мен­ная
<!-- example -->function checkscope() {
<!-- example -->    var scope = "local scope"; // Ло­каль­ная пе­ре­мен­ная
<!-- example -->    function f() { return scope; } // Вер­нет зна­че­ние ло­каль­ной пе­ре­мен­ной scope
<!-- example -->        return f;
<!-- example -->    }   
<!-- example -->checkscope()();
<!-- example --></code></pre>
                </br>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var a = 1;
<!-- example -->var foo = (function f1() {
<!-- example -->    var b = 2;
<!-- example -->    return (function f2() {
<!-- example -->        var c = 3;
<!-- example -->        return (function f3() {
<!-- example -->            var d = 4;
<!-- example -->            return function() {
<!-- example -->                console.log(a, b, c, d);
<!-- example -->            }
<!-- example -->        })();
<!-- example -->    })();
<!-- example -->})();
<!-- example -->foo();
<!-- example --></code></pre>
                </br>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var uniqueInteger = (function() {
<!-- example -->    var counter = 0; // Ча­ст­ное (private) зна­че­ние для функ­ции ни­же
<!-- example -->        return function() {
<!-- example -->            return counter++;
<!-- example -->        };
<!-- example -->}());
<!-- example --></code></pre>
            <p>
                Внимательно изучите этот пример, чтобы понять, как он действует. На первый взгляд, первая строка выглядит как инструкция присваивания функции переменной uniqueInteger. Фактически же это определение и вызов функции (как подсказывает открывающая круглая скобка в первой строке), поэтому в действительности переменной uniqueInteger присваивается значение, возвращаемое функцией. Если теперь обратить внимание на тело функции, можно увидеть, что она возвращает другую функцию. Именно этот объект вложенной функции и присваивается переменной uniqueInteger. Вложенная функция имеет доступ к переменным в ее области видимости и может использовать переменную counter, объявленную во внешней функции. После возврата из внешней функции никакой другой программный код не будет иметь доступа к переменной counter: вложенная функция будет обладать исключительным правом доступа к ней.
            </p>
            <p>
                Скрытые переменные, такие как counter, не являются исключительной собственностью единственного замыкания: в одной и той же внешней функции вполне возможно определить две или более вложенных функций, которые будут совместно использовать одну цепочку областей видимости. Рассмотрим следующий пример:
            </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->function counter() {
<!-- example -->    var n = 0;
<!-- example -->    return {
<!-- example -->        count: function() {
<!-- example -->            return ++n;
<!-- example -->        },
<!-- example -->        reset: function() {
<!-- example -->            n = 0;
<!-- example -->        }
<!-- example -->    };
<!-- example -->}
<!-- example -->var c = counter(), d = counter(); // Соз­дать два счет­чи­ка
<!-- example -->
<!-- example -->c.count() // => 1
<!-- example -->d.count() // => 1 // они дей­ст­ву­ют не­за­ви­си­мо
<!-- example -->c.reset()
<!-- example -->c.count()
<!-- example -->d.count()
<!-- example --></code></pre>
                <p>
                    Функция counter() возвращает объект «счетчика». Этот объект имеет два метода: count(), возвращающий следующее целое число, и reset(), сбрасывающий счетчик в начальное состояние. В первую очередь следует запомнить, что два метода совместно используют одну и ту же частную переменную n. Во-вторых, каждый вызов функции counter() создает новую цепочку областей видимости и новую скрытую переменную. То есть, если вызвать функцию counter() дважды, она вернет два объекта-счетчика с различными скрытыми переменными. Вызов методов count() и reset() одного объекта-счетчика не оказывает влияния на другой.
                </p>
                <p class="blockquote">
                    Почтенный мастер Ку Чи шел со своим учеником, Антоном. Надеясь вступить с мастером в дискуссию, Антон сказал: «Учитель, я слышал, что объекты это очень хорошая вещь — это правда?» Ку Чи с сожалением посмотрел на своего ученика и ответил: «Мой глупый ученик, объекты — это замыкания для бедных.» Антон поклонился и вернулся в свою келью изучать замыкания. Он внимательно прочитал всю серию работ «Lambda: The Ultimate…», потом все остальные статьи по этой теме, и создал небольшой интерпретатор с использованием объектов эмулирующих функционал замыканий. Он многому научился, и стал искать встречи с мастером, чтобы похвастаться. На своей следующей прогулке с Ку Чи, Антон сказал: «Учитель, я усердно изучал этот вопрос, и теперь понимаю, что объекты действительно являются замыканиями для бедных.» Ку Чи ударил Антона своей палкой и сказал: «Когда же ты научишься? Замыкания — это объекты для бедных». В этот самый момент Антон достиг просветления.
                </p>
                <p>
                    Как и объекты, замыкания предлагают механизм сохранения состояния. В JavaScript замыкание создается всякий раз, когда функция получает доступ к переменной, определенной вне непосредственной области видимости функции.
                </p>
                <p>
                    Похоже, что знания о замыкании полны предрассудков и суеверий как загадочный мир, стоящий особняком внутри JavaScript, который могут познать только самые храбрые души. Но на самом деле — это всего лишь стандартный и почти очевидный факт о том, как писать код в среде лексической области видимости, где функции являются значениями и могут свободно передаваться куда угодно.
                </p>
                <p>
                    Замыкание — это когда функция может запомнить и иметь доступ к своей лексической области видимости даже тогда, когда она вызывается вне своей лексической области видимости.
                </p>
            </article>
        </section>
<!---   SECTION8      -->
        <section class="clearfix" id="s8">
            <article class="main-article fl">
                <h3>8. Динамическая область видимости</h3>
                <p>
                    Мы кратко рассмотрим динамическую область видимости, чтобы крепко усвоить разницу.
                </p>
                <p>
                    Динамическая область видимости означает что есть модель, при помощи которой область видимости можно определить динамически во время выполнения, вместо статического определения при написании кода. То, что нам нужно. Давайте отразим это в коде:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->function foo() {
<!-- example -->    console.log( a ); // 2
<!-- example -->}
<!-- example -->
<!-- example -->function bar() {
<!-- example -->    var a = 3;
<!-- example -->    foo();
<!-- example -->}
<!-- example -->
<!-- example -->var a = 2;
<!-- example -->
<!-- example -->bar();
<!-- example --></code></pre>
                <p>
                    Лексическая область видимости хранит информацию о том, где была создана foo(), что приведет к тому, что будет выведено значение 2.
                </p>
                <p>
                    Динамическая область видимости, не интересуется тем как и где были объявлены функции и области видимости, а скорее интересуется тем откуда они буду вызываться. Здесь цепочка областей видимости основана на стеке вызовов, а не на вложенности областей видимости в коде.
                </p>
                <p>
                    Итак, если бы в JavaScript была динамическая область видимости, то когда выполнилась бы foo(), теоретически вышеприведенный код привел бы к выводу 3.
                </p>
                <p>
                    Чтобы внести ясность, в JavaScript нет, на самом деле, динамической области видимости. В нем есть лексическая область видимости. Проще некуда. Но механизм работы this немного похож на динамическую область видимости.
                </p>
                <p>
                    Ключевое сравнение: лексическая область видимости определяется временем написания кода, тогда как динамическая область видимости (и this!) определяется во время выполнения. Лексическую область видимости интересует где функция была объявлена, а динамическую — откуда была вызвана функция.
                </p>
                <p>
                    И наконец: this интересует как была вызвана функция, что показывает как близко связаны механизм this с идеей динамической области видимости.
                </p>
            </article>
        </section>
<!---   SECTION9      -->
        <section class="clearfix" id="s9">
            <article class="main-article fl">
                <h3>9. Паттерн Модуль</h3>
                <p>
                    Есть еще паттерны программирования, которые эффективно используют мощь замыканий, но которые внешне не особенно похожи на функции обратного вызова. Давайте рассмотрим самый мощный из них: <strong>модуль</strong>.
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->function foo() {
<!-- example -->    var something = "cool";
<!-- example -->    var another = [1, 2, 3];
<!-- example -->
<!-- example -->    function doSomething() {
<!-- example -->        console.log( something );
<!-- example -->    }
<!-- example -->
<!-- example -->    function doAnother() {
<!-- example -->        console.log( another.join( " ! " ) );
<!-- example -->    }
<!-- example -->}
<!-- example --></code></pre>
                <p>
                    Как видно из этого кода, здесь нет никакого явного замыкания. У нас просто есть некоторые приватные переменные something и another, а также парочка внутренних функций doSomething() и doAnother(), у обеих из которых есть лексическая область видимости (а потому и замыкание!) над внутренней областью foo().
                </p>
                <p>
                    А теперь смотрите:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->function CoolModule() {
<!-- example -->    var something = "cool";
<!-- example -->    var another = [1, 2, 3];
<!-- example -->
<!-- example -->    function doSomething() {
<!-- example -->        console.log( something );
<!-- example -->    }
<!-- example -->
<!-- example -->    function doAnother() {
<!-- example -->        console.log( another.join( " ! " ) );
<!-- example -->    }
<!-- example -->
<!-- example -->    return {
<!-- example -->        doSomething: doSomething,
<!-- example -->        doAnother: doAnother
<!-- example -->    };
<!-- example -->}
<!-- example -->
<!-- example -->var foo = CoolModule();
<!-- example -->
<!-- example -->foo.doSomething(); // cool
<!-- example -->foo.doAnother(); // 1 ! 2 ! 3
<!-- example --></code></pre>
                <p>
                    Этот шаблон в JavaScript мы называем модуль. Самый распространенный путь реализации шаблона модуля часто называют "Действенный модуль" и это тот вариант, который мы тут и представили.
                </p>
                <p>
                    Вышеприведенный код показывает автономный конструктор модуля с названием CoolModule(), который можно вызвать любое количество раз, каждый раз создавая новый экземпляр модуля. Небольшая вариация этого шаблона — это когда вы заботитесь о том, чтобы был только один экземпляр, что-то вроде "синглтона":
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var foo = (function CoolModule() {
<!-- example -->    var something = "cool";
<!-- example -->    var another = [1, 2, 3];
<!-- example -->
<!-- example -->    function doSomething() {
<!-- example -->        console.log( something );
<!-- example -->    }
<!-- example -->
<!-- example -->    function doAnother() {
<!-- example -->        console.log( another.join( " ! " ) );
<!-- example -->    }
<!-- example -->
<!-- example -->    return {
<!-- example -->        doSomething: doSomething,
<!-- example -->        doAnother: doAnother
<!-- example -->    };
<!-- example -->})();
<!-- example -->
<!-- example -->foo.doSomething(); // cool
<!-- example -->foo.doAnother(); // 1 ! 2 ! 3
<!-- example --></code></pre>
                <p>
                    Модули — это всего лишь функции, поэтому они могут принимать параметры:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->function CoolModule(id) {
<!-- example -->    function identify() {
<!-- example -->        console.log( id );
<!-- example -->    }
<!-- example -->
<!-- example -->    return {
<!-- example -->        identify: identify
<!-- example -->    };
<!-- example -->}
<!-- example -->
<!-- example -->var foo1 = CoolModule( "foo 1" );
<!-- example -->var foo2 = CoolModule( "foo 2" );
<!-- example -->
<!-- example -->foo1.identify(); // "foo 1"
<!-- example -->foo2.identify(); // "foo 2"
<!-- example --></code></pre>
                <p>
                    Еще одна небольшая, но полнофункциональная вариация модульного шаблона — дать имя объекту, который вы возвращаете как публичное API:
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var foo = (function CoolModule(id) {
<!-- example -->    function change() {
<!-- example -->        // modifying the public API
<!-- example -->        publicAPI.identify = identify2;
<!-- example -->    }
<!-- example -->
<!-- example -->    function identify1() {
<!-- example -->        console.log( id );
<!-- example -->    }
<!-- example -->
<!-- example -->    function identify2() {
<!-- example -->        console.log( id.toUpperCase() );
<!-- example -->    }
<!-- example -->
<!-- example -->    var publicAPI = {
<!-- example -->        change: change,
<!-- example -->        identify: identify1
<!-- example -->    };
<!-- example -->
<!-- example -->    return publicAPI;
<!-- example -->})( "foo module" );
<!-- example -->
<!-- example -->foo.identify(); // foo module
<!-- example -->foo.change();
<!-- example -->foo.identify(); // FOO MODULE
<!-- example --></code></pre>
                <p>
                    Сохраняя внутреннюю ссылку на объект публичного API внутри экземпляра модуля вы можете менять эту ссылку на модуль изнутри, включая добавление и удаление методов, свойств и изменение их значений.
                </p>
                <p>
                    Модули требуют две ключевых характеристики: 1) внешнюю функцию-обертку, которую будут вызывать, чтобы создать закрытую область видимости 2) возвращаемое значение функции-обертки должно включать в себя ссылку на не менее чем одну внутреннюю функцию, у которой потом будет замыкание на внутреннюю область видимости обертки.
                </p>
                <p>
                    Теперь вы сможете заметить замыкания повсюду в своем существующем коде и у нас теперь есть возможность обнаруживать и использовать все их преимущества!
                </p>
            </article>
        </section>
<!---   SECTION10      -->
        <section class="clearfix" id="s10">
            <article class="main-article fl">
                <h3>10. Объект arguments</h3>
                <p>
                    Если число аргументов в вызове функции превышает число имен параметров, функция лишается возможности напрямую обращаться к неименованным значениям. Решение этой проблемы предоставляет объект Arguments. В теле функции идентификатор arguments ссылается на объект Arguments, присутствующий в вызове. Объект Arguments – это объект, подобный массиву, позволяющий извлекать переданные функции значения по их номерам, а не по именам.
                </p>
                <p>
                    Предположим, что была определена функция f, которая требует один аргумент, x. Если вызвать эту функцию с двумя аргументами, то первый будет доступен внутри функции по имени параметра x или как arguments[0]. Второй аргумент будет доступен только как arguments[1]. Кроме того, подобно настоящим массивам, arguments имеет свойство length, определяющее количество содержащихся элементов. То есть в теле функции f, вызываемой с двумя аргументами, arguments.length имеет значение 2. 
                </p>
                <p>
                    Объект Arguments иллюстрирует важную возможность JavaScript-функций: они могут быть написаны таким образом, чтобы работать с любым количеством аргументов. Следующая функция принимает любое число аргументов и возвращает значение самого большого из них (аналогично ведет себя встроенная функция Math.max()).
                </p>
                <p>
                    Функции, подобные этой и способные принимать произвольное число аргументов, называются функциями с переменным числом аргументов (variadic functions, variable arity functions или varargs functions). Этот термин возник вместе с появлением языка программирования C.
                </p>
                <p>
                    Не следует забывать, что arguments фактически не является массивом – это объект Arguments. В каждом объекте Arguments имеются пронумерованные элементы массива и свойство length, но с технической точки зрения это не массив. Лучше рассматривать его как объект, имеющий некоторые пронумерованные свойства. 
                </p>
            </article>
        </section>
<!---   SECTION11      -->
        <section class="clearfix" id="s11">
            <article class="main-article fl">
                <h3>11. Устаревшая конструкция "with"</h3>
                <p>
                    Конструкция with позволяет использовать в качестве области видимости для переменных произвольный объект.
                </p>
                <p>
                    В современном JavaScript от этой конструкции отказались. С use strict она не работает, но её ещё можно найти в старом коде, так что стоит познакомиться с ней, чтобы если что – понимать, о чём речь.
                    </br>
                    </br>
                    Синтаксис:
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->with(obj) {
<!-- example -->  ...код...
<!-- example -->}
<!-- example --></code></pre>
                <p>
                    Любое обращение к переменной внутри with сначала ищет её среди свойств obj, а только потом – вне with.
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var a = 5;
<!-- example -->
<!-- example -->var obj = {
<!-- example -->    a: 10
<!-- example -->};
<!-- example -->
<!-- example -->with(obj) {
<!-- example -->    alert( a ); // 10, из obj
<!-- example -->}
<!-- example --></code></pre>
            </article>
        </section>
<!---   SECTION12      -->
        <section class="clearfix" id="s12">
            <article class="main-article fl">
                <h3>12. Упражнения</h3>
                <h4>1. Векторный тип</h4>
                <p>
                    Напишите конструктор Vector, представляющий вектор в двумерном пространстве. Он принимает параметры x и y (числа), которые хранятся в одноимённых свойствах.
                </p>
                <p>
                    Дайте Vector два метода, plus и minus, которые принимают другой вектор в качестве параметра и возвращают новый вектор, который хранит в x и y сумму или разность двух векторов (один this, второй – аргумент).
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->console.log(new Vector(1, 2).plus(new Vector(2, 3)));
<!-- example -->// → Vector{x: 3, y: 5}
<!-- example -->console.log(new Vector(1, 2).minus(new Vector(2, 3)));
<!-- example -->// → Vector{x: -1, y: -1}
<!-- example -->console.log(new Vector(3, 4).length); // Длина вектора
<!-- example --></code></pre>
                <p>
                    После, реализуйте модуль Vector. Вынесите интерфейс.
                </p>
                <h4>2. Названия месяцев</h4>
                <p>
                    Напишите простой модуль month, преобразующий номера месяцев (начиная с нуля) в названия и обратно. Выделите ему собственное пространство имён, т.к. ему потребуется внутренний массив с названиями месяцев.
                </p>
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->console.log(month.name(2));
<!-- example -->// → March
<!-- example -->console.log(month.number("November"));
<!-- example -->// → 10
<!-- example --></code></pre>
                <h4>3. Counter</h4>
                <p>
                    Реализуйте конструктор счет­чи­ка Counter(id), id уникальный идентификатор счетчика.
                    Counter.prototype.count - поле счет­чи­ка.
                    Counter.prototype.reset() - обнуляет счетчик.
                    set Counter.prototype.count(value) - позволяет установить счетчик.
                    get Counter.prototype.id - возвращает идентификатор счетчика.
                    Counter.prototype.autoCounting(timeout) - позволяет установить автоматическое увеличение счетчика через timeout.
                    Counter.prototype.startCounting(timeout) - запускает автоматическое увеличение счетчика.
                    Counter.prototype.stopCounting(timeout) - отменяет автоматическое увеличение счетчика.
                </p>
                <p>
                    После, реализуйте модуль Counter. Вынесите интерфейс.
                </p>
                <h4>4. allArguments</h4>
                <p>
                    Напишите функцию allArguments, что выводит в консоль все аргементы переданые функции ( количество аргументов зарание неизвесно).
                </p>
                <h4>5. allArgumentsAdd</h4>
                <p>
                    Напишите функцию allArgumentsAdd, что возвращает суму всех аргументов переданных функции (количество аргументов зарание неизвесно).
                </p>
                <h4>6. Car</h4>
                <p>
                    Создайте конструктор Car, детально описывающиющий свойство автомобиля (минимум 15 полей).
<!-- example --><pre><code class="javascript">'use strict';
<!-- example -->var chevy = new Car("Chevy", "Bel Air", 1957, "red", 2, false, 1021);
<!-- example -->var cadi = new Car("GM", "Cadillac", 1955, "tan", 5, false, 12892);
<!-- example -->var taxi = new Car("Webville Motors", "Taxi", 1955, "yellow", 4, false, 281341);
<!-- example -->var fiat = new Car("Fiat", "500", 1957, "Medium Blue", 2, false, 88000);
<!-- example --></code></pre>
                </p>
                <p>
                    Создайте массив марок автомобилей и на основе создайте массив из экземпляров Car(brand) (минимум 10 елементов).
                </p>
                <h4>6. Cars brand</h4>
                <p>
                    Создайте функцию, получает в качестве аргументов марки автомобилей и выводит их в консоль в одну строку через запятую и пробел.
                </p>
            </article>
        </section>
    </main>
    <footer></footer>
</div>
<script src="../js/highlight.pack.js"></script>
<script src="../js/highlightjs-line-numbers.js"></script>
<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>
<script src="../js/main.js"></script>
</body>
</html>

<!--
    <div class="article-images">
        <img src="images/web publishing.png" alt="">
    </div>
-->